{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"z390 Docs Home Note This is a work in progress. All contributions welcome to documentation See Contributing to docs","title":"z390 Docs Home"},{"location":"#z390-docs-home","text":"Note This is a work in progress. All contributions welcome to documentation See Contributing to docs","title":"z390 Docs Home"},{"location":"assist/","text":"ASSIST support ASSIST stands for A ssembler S ystem for S tudent I nstruction and S ystems T eaching. It is an IBM System/370-compatible assembler and interpreter developed in the early 1970s at Penn State University by Graham Campbell and John Mashey. 1 The ASSIST support in z390 allows you to use the I/O and debugging instructions as described in the ASSIST User Manual. See ASSIST User Manual PART II. INPUT/OUTPUT AND DEBUGGING INSTRUCTIONS for more details. Using ASSIST instructions with z390 ASSIST option The ASSIST option must be provided to use the ASSIST instructions. See z390 Options for details. assist command script z390 assist command script can be used to assemble, link, and execute ASSIST programs. assist {programname} The assist command script enables ASSIST option and defines the following files for input and output: XREAD={programname}.XRD XPRNT={programname}.XPR XPNCH={programname}.XPH XGET={programname}.XGT XPUT={programname}.XPT File processing Files are optional and will be opened on first access and closed at end of execution or end of file. All files are ASCII with automatic conversion from or to EBCDIC. ASCII file records have trailing spaces removed and end with carriage return x'0d' and line feed x'0a'. Input fields are padded with EBCDIC spaces x'40'. Non ASCII output bytes are converted to periods. Default ASSIST option behavior Using the ASSIST option enables z390 options NOLOADHIGH and NOINIT for compatibility with the original ASSIST assembler and simplifies relative address calculations. This has the following impacts: Programs are loaded at X'8000' instead of high end of memory. Registers are initialized to X'F4'. Memory above the PSA is initialized to X'F5'. Uninitialized areas of 390 load modules are initialized to X'F6'. You can use the options LOADHIGH and INIT to override this behavior. See z390 Options for more information. Error handling A trace table is used to display the last 10 instructions prior to abnormal termination of a program when the TRACE option is off. The PSW displayed at abnormal termination includes ILC, CC, MASK, and AMODE. ASSIST instructions XDECI - Convert decimal to binary Format: RX X'53rxbddd' r1.s2 Start scan for next decimal number at s2 skipping leading blanks. Convert decimal number to binary in r1 until non decimal character found or more than nine digits. When ten (or more) digits are found, the instruction does not do the conversion and condition code 3 is set. Set register 1 to address of the last non decimal character found. Set condition code 0 if number converted successfully else set condition code 3. XDECO - Convert binary to decimal Format: RX X'52rxbddd' r1,s2 Convert binary 32 bit r1 value to right justified 12 character decimal field at s2. XDUMP - dump registers and/or storage Format: RXSS X'E06xbdddbddd' s1(x1),s2 If no operands are specified, dump registers and the default storage area. If no XLIMD instruction has reset default storage dump area, dump all storage. if s1(x1) address of storage area and s2 length of area are specified just dump that area. XGET - read record from ASCII file Format: RXSS X'E0Axbdddbddd' s1(x1),s2 Read record from ASCII file DDNAME=XGET into area s1(x1) with length of s2. Requires that the environment variable XGET be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set. XHEXI - convert hex to binary Format: RX X'61' r1,s2 Convert hex to binary (cc3 if no hex, update field addr). XHEXO - convert binary to hex Format: RX X'62' r1,s2 Convert value in r1 to printable hex (8 bytes), storing value at s2. XLIMD - Set default dump storage area Format: RXSS X'E08xrbdddbddd' s1(x1),s2 Set default XDUMP storage area address and length. XPNCH - Write to punch Format: RXSS X'E04xbdddbddd' s1(x1),s2 Write to DDNAME=XPNCH with length s2. Requires that the environment variable XPNCH be set and point to desired output file. Does not set condition code. If a file error occurs the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. XPRNT - Write to print Format: RXSS X'E02xbdddbddd' s1(x1),s2 Write to DDNAME=XPRNT with length s2. Requires that the environment variable XPRNT be set and point to desired output file. Does not set condition code. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. XPUT - Write to XPUT Format: RXSS X'E0Cxbdddbddd' s1(x1),s2 Write to DDNAME=XPUT for length s2. Requires that the environment variable XPUT be set and point to desired output file. If a file operation is successful the condition code is set to 0. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set. XREAD - Read from XREAD Format: RXSS X'E00xbdddbddd' s1(x1),s2 Read record from DDNAME=XREAD for length s2. Requires that the environment variable XREAD be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. See ASSIST (computing) at Wikipedia for more details. \u21a9","title":"ASSIST support"},{"location":"assist/#assist-support","text":"ASSIST stands for A ssembler S ystem for S tudent I nstruction and S ystems T eaching. It is an IBM System/370-compatible assembler and interpreter developed in the early 1970s at Penn State University by Graham Campbell and John Mashey. 1 The ASSIST support in z390 allows you to use the I/O and debugging instructions as described in the ASSIST User Manual. See ASSIST User Manual PART II. INPUT/OUTPUT AND DEBUGGING INSTRUCTIONS for more details.","title":"ASSIST support"},{"location":"assist/#using-assist-instructions-with-z390","text":"","title":"Using ASSIST instructions with z390"},{"location":"assist/#assist-option","text":"The ASSIST option must be provided to use the ASSIST instructions. See z390 Options for details.","title":"ASSIST option"},{"location":"assist/#assist-command-script","text":"z390 assist command script can be used to assemble, link, and execute ASSIST programs. assist {programname} The assist command script enables ASSIST option and defines the following files for input and output: XREAD={programname}.XRD XPRNT={programname}.XPR XPNCH={programname}.XPH XGET={programname}.XGT XPUT={programname}.XPT","title":"assist command script"},{"location":"assist/#file-processing","text":"Files are optional and will be opened on first access and closed at end of execution or end of file. All files are ASCII with automatic conversion from or to EBCDIC. ASCII file records have trailing spaces removed and end with carriage return x'0d' and line feed x'0a'. Input fields are padded with EBCDIC spaces x'40'. Non ASCII output bytes are converted to periods.","title":"File processing"},{"location":"assist/#default-assist-option-behavior","text":"Using the ASSIST option enables z390 options NOLOADHIGH and NOINIT for compatibility with the original ASSIST assembler and simplifies relative address calculations. This has the following impacts: Programs are loaded at X'8000' instead of high end of memory. Registers are initialized to X'F4'. Memory above the PSA is initialized to X'F5'. Uninitialized areas of 390 load modules are initialized to X'F6'. You can use the options LOADHIGH and INIT to override this behavior. See z390 Options for more information.","title":"Default ASSIST option behavior"},{"location":"assist/#error-handling","text":"A trace table is used to display the last 10 instructions prior to abnormal termination of a program when the TRACE option is off. The PSW displayed at abnormal termination includes ILC, CC, MASK, and AMODE.","title":"Error handling"},{"location":"assist/#assist-instructions","text":"","title":"ASSIST instructions"},{"location":"assist/#xdeci-convert-decimal-to-binary","text":"Format: RX X'53rxbddd' r1.s2 Start scan for next decimal number at s2 skipping leading blanks. Convert decimal number to binary in r1 until non decimal character found or more than nine digits. When ten (or more) digits are found, the instruction does not do the conversion and condition code 3 is set. Set register 1 to address of the last non decimal character found. Set condition code 0 if number converted successfully else set condition code 3.","title":"XDECI - Convert decimal to binary"},{"location":"assist/#xdeco-convert-binary-to-decimal","text":"Format: RX X'52rxbddd' r1,s2 Convert binary 32 bit r1 value to right justified 12 character decimal field at s2.","title":"XDECO - Convert binary to decimal"},{"location":"assist/#xdump-dump-registers-andor-storage","text":"Format: RXSS X'E06xbdddbddd' s1(x1),s2 If no operands are specified, dump registers and the default storage area. If no XLIMD instruction has reset default storage dump area, dump all storage. if s1(x1) address of storage area and s2 length of area are specified just dump that area.","title":"XDUMP - dump registers and/or storage"},{"location":"assist/#xget-read-record-from-ascii-file","text":"Format: RXSS X'E0Axbdddbddd' s1(x1),s2 Read record from ASCII file DDNAME=XGET into area s1(x1) with length of s2. Requires that the environment variable XGET be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set.","title":"XGET - read record from ASCII file"},{"location":"assist/#xhexi-convert-hex-to-binary","text":"Format: RX X'61' r1,s2 Convert hex to binary (cc3 if no hex, update field addr).","title":"XHEXI - convert hex to binary"},{"location":"assist/#xhexo-convert-binary-to-hex","text":"Format: RX X'62' r1,s2 Convert value in r1 to printable hex (8 bytes), storing value at s2.","title":"XHEXO - convert binary to hex"},{"location":"assist/#xlimd-set-default-dump-storage-area","text":"Format: RXSS X'E08xrbdddbddd' s1(x1),s2 Set default XDUMP storage area address and length.","title":"XLIMD - Set default dump storage area"},{"location":"assist/#xpnch-write-to-punch","text":"Format: RXSS X'E04xbdddbddd' s1(x1),s2 Write to DDNAME=XPNCH with length s2. Requires that the environment variable XPNCH be set and point to desired output file. Does not set condition code. If a file error occurs the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed.","title":"XPNCH - Write to punch"},{"location":"assist/#xprnt-write-to-print","text":"Format: RXSS X'E02xbdddbddd' s1(x1),s2 Write to DDNAME=XPRNT with length s2. Requires that the environment variable XPRNT be set and point to desired output file. Does not set condition code. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed.","title":"XPRNT - Write to print"},{"location":"assist/#xput-write-to-xput","text":"Format: RXSS X'E0Cxbdddbddd' s1(x1),s2 Write to DDNAME=XPUT for length s2. Requires that the environment variable XPUT be set and point to desired output file. If a file operation is successful the condition code is set to 0. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set.","title":"XPUT - Write to XPUT"},{"location":"assist/#xread-read-from-xread","text":"Format: RXSS X'E00xbdddbddd' s1(x1),s2 Read record from DDNAME=XREAD for length s2. Requires that the environment variable XREAD be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. See ASSIST (computing) at Wikipedia for more details. \u21a9","title":"XREAD - Read from XREAD"},{"location":"contribute_docs/","text":"Contributing to z390 Documentation The following document will provide details on developing z390 documentation. It is expected that as part of contributing to the code base, that you also update any documentation impacted by the change. All documentation will be held in the doc folder and be in markdown format. Markdown files have a .md extension. Markdown uses simple text files with specific syntax for formatting. See the markdown guide for syntax. You can also use functions provided by the admonition extension in mkdocs. See the doco for admonition Conventions Product names Product names should always use a small z: z390 zCOBOL - Always capitalize COBOL zVSAM - Always capitalize VSAM zCICS - Always capitalize CICS Program names and scripts When specifying tool and script names, always use lower case to be compatible with case sensitive environments like linux. mz390 az390 asmlg Units of measurement For bytes: When specifying a quantity of 1024 bytes, use {quantity}K. Bytes is assumed. Capital K is deliberate. the word bytes can be added if the context does not make it clear that bytes are implied. {quantity}K bytes. For seconds: ms = millisecond \u00b5s = microseconds (in markdown \u00b5 = &micro; ) ns = nanoseconds Code HLASM code should be enclosed in a code block as follows: ``` hlasm LABEL MVC X(10),Y ``` Terminology The following provides guidelines on the use of specific terminology. If not here, you should use the general principle of following conventions set in IBM mainframe manuals. term usage word OK. Alternate is fullword with no space. halfword OK. No space should be used. save area In any text, ensure space is included. The only exception is in code savearea without space is preferred ASCII Always in capitals EBCDIC Always in capitals PSW Program status word - Always capitals Preview the web pages The z390 docs use the Python utility mkdocs to convert the markdown to web pages that are published to GitHub pages. The following instructions will allow you to preview the published version on GitHub prior to committing your changes. Installation You will need some version of Python, and the version should be 3.4 or above. MacOS/Unix python -m venv docenv source docenv/bin/activate pip install -r doc/requirements.txt Windows python -m venv docenv docenv\\Scripts\\activate pip install -r doc\\requirements.txt Run the live web server When updating the markdown content, you can run a live web server which checks for changes in the markdown files and updates the web content as you edit. You can view the web site preview using a web browser pointed at the following address: http://localhost:8000 MacOS/Unix source docenv/bin/activate mkdocs serve Windows docenv\\Scripts\\activate mkdocs serve","title":"Contributing to z390 Documentation"},{"location":"contribute_docs/#contributing-to-z390-documentation","text":"The following document will provide details on developing z390 documentation. It is expected that as part of contributing to the code base, that you also update any documentation impacted by the change. All documentation will be held in the doc folder and be in markdown format. Markdown files have a .md extension. Markdown uses simple text files with specific syntax for formatting. See the markdown guide for syntax. You can also use functions provided by the admonition extension in mkdocs. See the doco for admonition","title":"Contributing to z390 Documentation"},{"location":"contribute_docs/#conventions","text":"","title":"Conventions"},{"location":"contribute_docs/#product-names","text":"Product names should always use a small z: z390 zCOBOL - Always capitalize COBOL zVSAM - Always capitalize VSAM zCICS - Always capitalize CICS","title":"Product names"},{"location":"contribute_docs/#program-names-and-scripts","text":"When specifying tool and script names, always use lower case to be compatible with case sensitive environments like linux. mz390 az390 asmlg","title":"Program names and scripts"},{"location":"contribute_docs/#units-of-measurement","text":"For bytes: When specifying a quantity of 1024 bytes, use {quantity}K. Bytes is assumed. Capital K is deliberate. the word bytes can be added if the context does not make it clear that bytes are implied. {quantity}K bytes. For seconds: ms = millisecond \u00b5s = microseconds (in markdown \u00b5 = &micro; ) ns = nanoseconds","title":"Units of measurement"},{"location":"contribute_docs/#code","text":"HLASM code should be enclosed in a code block as follows: ``` hlasm LABEL MVC X(10),Y ```","title":"Code"},{"location":"contribute_docs/#terminology","text":"The following provides guidelines on the use of specific terminology. If not here, you should use the general principle of following conventions set in IBM mainframe manuals. term usage word OK. Alternate is fullword with no space. halfword OK. No space should be used. save area In any text, ensure space is included. The only exception is in code savearea without space is preferred ASCII Always in capitals EBCDIC Always in capitals PSW Program status word - Always capitals","title":"Terminology"},{"location":"contribute_docs/#preview-the-web-pages","text":"The z390 docs use the Python utility mkdocs to convert the markdown to web pages that are published to GitHub pages. The following instructions will allow you to preview the published version on GitHub prior to committing your changes.","title":"Preview the web pages"},{"location":"contribute_docs/#installation","text":"You will need some version of Python, and the version should be 3.4 or above.","title":"Installation"},{"location":"contribute_docs/#macosunix","text":"python -m venv docenv source docenv/bin/activate pip install -r doc/requirements.txt","title":"MacOS/Unix"},{"location":"contribute_docs/#windows","text":"python -m venv docenv docenv\\Scripts\\activate pip install -r doc\\requirements.txt","title":"Windows"},{"location":"contribute_docs/#run-the-live-web-server","text":"When updating the markdown content, you can run a live web server which checks for changes in the markdown files and updates the web content as you edit. You can view the web site preview using a web browser pointed at the following address: http://localhost:8000","title":"Run the live web server"},{"location":"contribute_docs/#macosunix_1","text":"source docenv/bin/activate mkdocs serve","title":"MacOS/Unix"},{"location":"contribute_docs/#windows_1","text":"docenv\\Scripts\\activate mkdocs serve","title":"Windows"},{"location":"file_services/","text":"Non-VSAM File Services z390 supports sequential and random access to files through the provision of SVC functions and assembler macros. The macros described here seek to emulate those provided by IBM\u00ae as part of their operating system macro services where it makes sense in the context of z390 runtime environments. z/OS: DFSMS Macro Instructions for Data Sets - Part 2 Non-VSAM macro instructions. VSAM support The macros GET, PUT and POINT can be used for VSAM access with the parameter RPL=rpladdress. VSAM usage is not documented here. Please refer to VSAM file services . Quick starts To access a file, a data control block (DCB) must be defined. Programs that use the File I/O macros must include a DSECT for the DCB. The DSECT is generated by the DCBD macro, so a typical program structure would be: DCBD EQUREGS END Include the DSECT for the DECB, which is generated by the DECBD macro, if you are using READ or WRITE. Read a file The following code demonstrates the read of a file TEACHERS with a layout as described as IREC . The environment variable TEACHER should be set to point to the input file. OPEN (TEACHERS,INPUT) Opens the file GET TEACHERS Reads record CLOSE TEACHERS Closes the file ...... TEACHERS DCB LRECL=27,RECFM=FT,MACRF=R,EODAD=ATEND, X DDNAME=TEACHER,RECORD=IREC IREC DS 0CL27 Teacher record ...... Write to a file The following code demonstrates the write to a file REPORT with a layout as described as OREC . The environment variable REPORT should be set to point to the output file. OPEN (REPORT,OUTPUT) Opens the file PUT REPORT,OREC Write OREC to record CLOSE REPORT Closes the file ...... REPORT DCB LRECL=60,RECFM=FT,MACRF=W, X DDNAME=REPORT OREC DS 0CL60 Report output structure ...... Macro reference Terminology Term Definition dcbname the label on the DCB macro. reg general register, avoid 0, 1, 14 or 15. type INPUT, OUTPUT or UPDATE (default is INPUT). ioarea label of the I/O area for the record to be read/written. decbname internal or external DECB for controlling READ/WRITE. rel relative record number. rba relative byte address. DCB - Data Control Block Used to create the Data Control Block Some of the parameters may be set before and/or after OPEN. The individual descriptions indicate this. label DCB DSORG=PS, X EODAD=0, X RECFM=FB, X DDNAME=, X MACRF=GM, X SYNAD=0, X BLKSIZE=0, X LRECL=0, X DCBE=, X RECORD=0, X DSNAME=0 EXLST is currently unsupported. 'label' is the file identifier, the DCB name, which is used in all the file I/O macros. Term Meaning Description BDW Block Descriptor Word Only used for RECFM=VB files. A 4-byte field of the form 'blocklength',H'0' The blocklength includes the length of the BDW. RDW Record Descriptor Word Used for all variable files. A 4-byte field of the form H'recordlength',H'0' The recordlength includes the length of the RDW. The program must set this field correctly for output, and expect it on input. CRLF Carriage Return, Line Feed A term for the hex string X'0D0A' (ASCII) or X'0D25' (EBCDIC). Now commonly used to terminate a text record. DDNAME and DSNAME - DD statement/Dataset name DDNAME DSECT=DCBDDNAM Type=CL8 Default=CL8'label' DSNAME DSECT=DCBDSNAM Type=A No default Can these be set in the DCB prior to OPEN: Yes Can these be set in the DCB after OPEN : No Only one of these parameters may be set in the DCB. If both parameters are set in the program prior to open, the DSNAME will take precedence. When DDNAME is specified, an environment variable will point to the path and file that is to be opened. Within a program the GETENV macro can be used to extract the environment variable. See GETENV macro for full details. MYDCB DCB DDNAME=MYDATA, ... For execution in a Windows environment: SET MYDATA=c:\\path\\file CALL c:\\path_to_z390\\bat\\ez390 c:\\path\\program parms For execution in a *nix environment export MYDATA=/path/file /path_to_z390/bash/ez390 /path/program parms Info For both Windows and *nix, the invocation of ez390 should be preceded by a path to the z390 script folder. bat for Windows bash for *nix DSNAME is a label defined in the program which has the file spec. The file spec must terminate with X'00' or be defined as a double-quoted string within a standard C-type constant. MYDCB DCB DSNAME=MYDATA, ... ...... MYDATA DC C'drive:\\path\\file',X'00' MYDATA DC C'\"drive:\\path\\file\"' MACRF - Macro type DSECT=DCBMACRF, Coded Default=GM Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No Option Effect MACRF=GM Get Move, use the GET macro to read a record Use for standard (QSAM) file read MACRF=PM Put Move, use the PUT macro to write a record Use for standard (QSAM) file write MACRF=R Read Mode. Use READ/CHECK to read a record. Use POINT for positioning. MACRF=W Write Mode. Use WRITE/CHECK to write or update a record. Use POINT for positioning. MACRF=RW Update Mode. Use READ/WRITE/CHECK to read, write or update a record. Use POINT for positioning. DSORG - Dataset organization DSORG DSECT=DCBDSORG Coded Default=PS Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No DSORG=PS Physical Sequential The only option at present, can be omitted. RECFM - Record format RECFM DSECT=DCBRECFM Coded Default=FB Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No RECFM=F Fixed Translation: None Input: Records are read LRECL at a time. Output: Records are written LRECL at a time. RECFM=FB Fixed Blocked Translation: None Input: MACRF=GM Records are read LRECL at a time out of BLKSIZE. MACRF=R or RW The whole block is read. Output: MACRF=PM Records are written LRECL at a time into a block of size BLKSIZE. CLOSE may write a short block. MACRF=W or RW The whole block is written. RECFM=V Variable Translation: None Input: Each record is prefixed by the RDW. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. Output: Each record must be prefixed by the RDW. RECFM=VB Variable Blocked Translation: None Input: MACRF=GM Each record is prefixed by the RDW. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. MACRF=R or RW The whole block is read, prefixed by the BDW. The receiving area must be big enough for the largest BDW+block. If the BDW indicates a block size larger than BLKSIZE, abend S013 will occur. Output: MACRF=PM Each record must be prefixed by the RDW. CLOSE will write the last block. Each block written will have the BDW automatically inserted at the start. MACRF=W or RW Each block must be prefixed by the BDW. RECFM=FT Fixed ASCII text Translation: ASCII mode: None Non-ASCII mode input ASCII chars are translated to EBCDIC after being read. Non-ASCII mode output EBCDIC chars are translated to ASCII before being written, this is an internal function and does not affect the record in storage. Non-EBCDIC chars may be translated to X'00'. Input: The file is assumed to be in conventional ASCII format, with each record ending in the operating system specific end-of-line (EOL) character(s). EOL is never read as part of the record. If the record is shorter than LRECL, then trailing blanks are inserted. EODAD is invoked when all bytes have been read. Output: EOL is inserted at the end of each record after trailing blanks are stripped. RECFM=VT Variable ASCII text Translation: ASCII mode None Non-ASCII mode input ASCII chars are translated to EBCDIC after being read. Non-ASCII mode output EBCDIC chars are translated to ASCII before being written. This is an internal function and does not affect the record in storage. Non-EBCDIC chars may be translated to X'00'. Input: The file is assumed to be in conventional ASCII format, with each record ending in the operating system specific end-of-line (EOL) character(s). EOL is never read as part of the record. Each record is prefixed with the RDW. EODAD is invoked when all bytes have been read. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. Output: Each record must be prefixed with the RDW. EOL is inserted at the end of each record after trailing blanks are stripped. Warning The RDW is not written. RECORD - Record address RECORD DSECT=DCBREC Type=A Default=0 (undefined) Default I/O area which can be overridden on the GET/PUT/READ/WRITE macros. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes If omitted, then the I/O area must be specified on the GET/PUT/READ/WRITE macros. LRECL - Record length LRECL DSECT=DCBLRECLF Type=F Default=0 Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes Maximum value is 2G-1. For RECFM=F or FB, sets the record size. For all other RECFM, sets the maximum record size. For RECFM=F, LRECL=0 is valid, provided that BLKSIZE is set. For RECFM=FB, LRECL must be a multiple of BLKSIZE. For variable records, include 4 for the RDW. The field DCBLRECL (Type=H) is retained for compatibility. BLKSIZE - Block size BLKSIZE DSECT=DCBBLKSIF Type=F Default=0 Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes Maximum value is 2G-1. LRECL and BLKSIZE cannot both be zero. For RECFM=F sets the record size if LRECL=0. For RECFM=FB, sets the block size and LRECL must be a multiple of BLKSIZE. For RECFM=VB, BLKSIZE must be at least 4 greater than LRECL. For all other RECFM, sets the maximum block size. The field DCBBLKSI (Type=H) is retained for compatibility. DCBE - Data control block extension DCBE DSECT=DCBDCBE Type=A Default=0 (undefined) The DCBE is a control block defined by the DCBE macro. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes When defined, the addresses of the end-of-file (EODAD) and the I/O error routine (SYNAD) may be defined. When set, these addresses override the DCB EODAD and SYNAD parameters. The DSECT IHADCBE maps the DCBE control block. EODAD - End of file routine EODAD DSECT=DCBEODAD Type=Address Default=0 (no routine defined) The address of the end-of-file routine. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes This may be overridden if DCBE is coded. If a further GET is done after end-of-file, then the program is terminated. SYNAD - Error analysis routine SYNAD DSECT=DCBSYNAD Type=Address Default=0 (no routine defined) The address of the uncorrectable I/O error routine. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes This may be overridden if DCBE is coded. DCBE - Data Control Block Extended label DCBE EODAD=0,SYNAD=0,BLKSIZE=0 EODAD - End of data routine address Address of End of data routine. Default=0 = no routine When set, will override address provided in the DCB EODAD parameter. SYNAD - IO error routine address Address of IO Error routine. Default=0 - no routine When set, will override address provided in the DCB SYNAD parameter. BLKSIZE - Large block interface Default is zero meaning Large Block support is not enabled. When set, the large block interface (LBI) is enabled. This causes BDW and RDW fields in variable length files to use an alternative format: LLLL where high bit is on and the remaining 31 bits are length. DTFSD (VSE) - Data control block VSE only DTFSD maps to the standard DCB as follows: label DTFSD BLKSIZE=n, X EOFADDR= label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0 DTFPR (VSE) - Data control block VSE only DTFPR maps to the standard DCB as follows: label DTFPR BLKSIZE=n label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0 OPEN - Open file Open one or more files. Usage Open one file for INPUT OPEN dcbname Open one file for non-INPUT OPEN (dcbname,type) Open multiple files OPEN (dcbname1,type,dcbname2,type) The same, using register notation OPEN ((reg),type) OPEN ((reg1),type,(reg2),type) Registers R0 = Flags R1 = DCB addresses Abends S013 OPEN failed and no SYNAD exit provided OPEN (VSE) - Open file Open one or more files for UPDATE. Usage OPEN dtfname OPEN (dtfname1,dtfname2,...) Registers R0 = Flags R1 = DTF addresses Abends S013 OPEN failed and no SYNAD exit provided CLOSE - Close file Close one or more files. Usage Close one file CLOSE dcbname Close multiple files CLOSE (dcbname1,,dcbname2) The same, using register notation CLOSE ((reg1),,(reg2)) Registers R1 = DCB addresses Abends S013 CLOSE failed and no SYNAD exit provided CLOSE (VSE) - Close file Close one or more files. Usage CLOSE (dtfname1,dtfname2,...) Registers R1 = DTF addresses Abends S013 CLOSE failed and no SYNAD exit provided GET - Read sequential record Read a sequential record Usage Read a record into an I/O area supplied on DCB RECORD=ioarea GET dcbname Read a record into an I/O area GET dcbname,ioarea The same, using register notation GET (reg) GET (reg1),(reg2) Registers R0 = ioarea R1 = DCB address PUT - Write a sequential record Write a sequential record Usage Write a record from an I/O area supplied on the DCB RECORD=ioarea PUT dcbname Write a record from an I/O area PUT dcbname,ioarea The same, using register notation PUT (reg) PUT (reg1),(reg2) Registers R0 = ioarea R1 = DCB address READ - Read block from file Read a block from a file. If EODAD or SYNAD result from the READ, they will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB. Usage Read a block using an internal DECB, into an I/O area supplied on the DCB RECORD=ioarea READ decbname,,dcbname Read a block using an internal DECB into an I/O area. The I/O area must be at least as large as DCB BLKSIZE READ decbname,,dcbname,ioarea The same, using register notation READ (reg1),,(reg2) READ (reg1),,(reg2),(reg3) Registers R0 = work register R1 = DECB address R15= DCB address WRITE - Write block to file Write a block to a file. If SYNAD results from the WRITE, it will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB. Usage Write a block using an internal DECB, from an I/O area supplied on the DCB RECORD=ioarea WRITE decbname,,dcbname Write a block using an internal DECB from an I/O area WRITE decbname,,dcbname,ioarea The same, using register notation WRITE (reg1),,(reg2) WRITE (reg1),,(reg2),(reg3) Registers R0 = work register R1 = DECB address R15= DCB address CHECK - Process EODAD/SYNAD Process EODAD or SYNAD on READ. Process SYNAD on WRITE. Usage CHECK decbname The same, using register notation CHECK (reg) Registers R1 = DECB address Abends S013 READ/WRITE failed and no SYNAD exit provided POINT - Position file pointer Position pointer for next READ or WRITE When register notation is used for rba or rel, the register points to a field containing the value. rel is a fullword, maximum value 2,147,483,647 (2G - 1). rel is multiplied by BLKSIZE to get the rba. rba is signed 64-bit value. Usage Point to a record using relative record number POINT dcbname,rel Point to a record using relative byte address POINT dcbname,,RBA=rba The same, using register notation POINT (reg1),(reg2) POINT (reg1),,RBA=(reg2) Registers R0 = rel or RBA R1 = DCB address R15= Blocksize SVC functions The following is a list of the z390 SVC services that support the above macros. DEC HEX Service 19 13 OPEN 19 13 OPEN (VSE) 20 14 CLOSE 20 14 CLOSE (VSE) 151 97 GET 152 98 PUT 153 99 READ 154 9A WRITE 155 9B CHECK 156 9C POINT","title":"Non-VSAM File Services"},{"location":"file_services/#non-vsam-file-services","text":"z390 supports sequential and random access to files through the provision of SVC functions and assembler macros. The macros described here seek to emulate those provided by IBM\u00ae as part of their operating system macro services where it makes sense in the context of z390 runtime environments. z/OS: DFSMS Macro Instructions for Data Sets - Part 2 Non-VSAM macro instructions. VSAM support The macros GET, PUT and POINT can be used for VSAM access with the parameter RPL=rpladdress. VSAM usage is not documented here. Please refer to VSAM file services .","title":"Non-VSAM File Services"},{"location":"file_services/#quick-starts","text":"To access a file, a data control block (DCB) must be defined. Programs that use the File I/O macros must include a DSECT for the DCB. The DSECT is generated by the DCBD macro, so a typical program structure would be: DCBD EQUREGS END Include the DSECT for the DECB, which is generated by the DECBD macro, if you are using READ or WRITE.","title":"Quick starts"},{"location":"file_services/#read-a-file","text":"The following code demonstrates the read of a file TEACHERS with a layout as described as IREC . The environment variable TEACHER should be set to point to the input file. OPEN (TEACHERS,INPUT) Opens the file GET TEACHERS Reads record CLOSE TEACHERS Closes the file ...... TEACHERS DCB LRECL=27,RECFM=FT,MACRF=R,EODAD=ATEND, X DDNAME=TEACHER,RECORD=IREC IREC DS 0CL27 Teacher record ......","title":"Read a file"},{"location":"file_services/#write-to-a-file","text":"The following code demonstrates the write to a file REPORT with a layout as described as OREC . The environment variable REPORT should be set to point to the output file. OPEN (REPORT,OUTPUT) Opens the file PUT REPORT,OREC Write OREC to record CLOSE REPORT Closes the file ...... REPORT DCB LRECL=60,RECFM=FT,MACRF=W, X DDNAME=REPORT OREC DS 0CL60 Report output structure ......","title":"Write to a file"},{"location":"file_services/#macro-reference","text":"","title":"Macro reference"},{"location":"file_services/#terminology","text":"Term Definition dcbname the label on the DCB macro. reg general register, avoid 0, 1, 14 or 15. type INPUT, OUTPUT or UPDATE (default is INPUT). ioarea label of the I/O area for the record to be read/written. decbname internal or external DECB for controlling READ/WRITE. rel relative record number. rba relative byte address.","title":"Terminology"},{"location":"file_services/#dcb-data-control-block","text":"Used to create the Data Control Block Some of the parameters may be set before and/or after OPEN. The individual descriptions indicate this. label DCB DSORG=PS, X EODAD=0, X RECFM=FB, X DDNAME=, X MACRF=GM, X SYNAD=0, X BLKSIZE=0, X LRECL=0, X DCBE=, X RECORD=0, X DSNAME=0 EXLST is currently unsupported. 'label' is the file identifier, the DCB name, which is used in all the file I/O macros. Term Meaning Description BDW Block Descriptor Word Only used for RECFM=VB files. A 4-byte field of the form 'blocklength',H'0' The blocklength includes the length of the BDW. RDW Record Descriptor Word Used for all variable files. A 4-byte field of the form H'recordlength',H'0' The recordlength includes the length of the RDW. The program must set this field correctly for output, and expect it on input. CRLF Carriage Return, Line Feed A term for the hex string X'0D0A' (ASCII) or X'0D25' (EBCDIC). Now commonly used to terminate a text record.","title":"DCB - Data Control Block"},{"location":"file_services/#ddname-and-dsname-dd-statementdataset-name","text":"DDNAME DSECT=DCBDDNAM Type=CL8 Default=CL8'label' DSNAME DSECT=DCBDSNAM Type=A No default Can these be set in the DCB prior to OPEN: Yes Can these be set in the DCB after OPEN : No Only one of these parameters may be set in the DCB. If both parameters are set in the program prior to open, the DSNAME will take precedence. When DDNAME is specified, an environment variable will point to the path and file that is to be opened. Within a program the GETENV macro can be used to extract the environment variable. See GETENV macro for full details. MYDCB DCB DDNAME=MYDATA, ... For execution in a Windows environment: SET MYDATA=c:\\path\\file CALL c:\\path_to_z390\\bat\\ez390 c:\\path\\program parms For execution in a *nix environment export MYDATA=/path/file /path_to_z390/bash/ez390 /path/program parms Info For both Windows and *nix, the invocation of ez390 should be preceded by a path to the z390 script folder. bat for Windows bash for *nix DSNAME is a label defined in the program which has the file spec. The file spec must terminate with X'00' or be defined as a double-quoted string within a standard C-type constant. MYDCB DCB DSNAME=MYDATA, ... ...... MYDATA DC C'drive:\\path\\file',X'00' MYDATA DC C'\"drive:\\path\\file\"'","title":"DDNAME and DSNAME - DD statement/Dataset name"},{"location":"file_services/#macrf-macro-type","text":"DSECT=DCBMACRF, Coded Default=GM Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No Option Effect MACRF=GM Get Move, use the GET macro to read a record Use for standard (QSAM) file read MACRF=PM Put Move, use the PUT macro to write a record Use for standard (QSAM) file write MACRF=R Read Mode. Use READ/CHECK to read a record. Use POINT for positioning. MACRF=W Write Mode. Use WRITE/CHECK to write or update a record. Use POINT for positioning. MACRF=RW Update Mode. Use READ/WRITE/CHECK to read, write or update a record. Use POINT for positioning.","title":"MACRF - Macro type"},{"location":"file_services/#dsorg-dataset-organization","text":"DSORG DSECT=DCBDSORG Coded Default=PS Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No","title":"DSORG - Dataset organization"},{"location":"file_services/#dsorgps-physical-sequential","text":"The only option at present, can be omitted.","title":"DSORG=PS Physical Sequential"},{"location":"file_services/#recfm-record-format","text":"RECFM DSECT=DCBRECFM Coded Default=FB Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No","title":"RECFM - Record format"},{"location":"file_services/#recfmf-fixed","text":"Translation: None Input: Records are read LRECL at a time. Output: Records are written LRECL at a time.","title":"RECFM=F Fixed"},{"location":"file_services/#recfmfb-fixed-blocked","text":"Translation: None Input: MACRF=GM Records are read LRECL at a time out of BLKSIZE. MACRF=R or RW The whole block is read. Output: MACRF=PM Records are written LRECL at a time into a block of size BLKSIZE. CLOSE may write a short block. MACRF=W or RW The whole block is written.","title":"RECFM=FB Fixed Blocked"},{"location":"file_services/#recfmv-variable","text":"Translation: None Input: Each record is prefixed by the RDW. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. Output: Each record must be prefixed by the RDW.","title":"RECFM=V Variable"},{"location":"file_services/#recfmvb-variable-blocked","text":"Translation: None Input: MACRF=GM Each record is prefixed by the RDW. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. MACRF=R or RW The whole block is read, prefixed by the BDW. The receiving area must be big enough for the largest BDW+block. If the BDW indicates a block size larger than BLKSIZE, abend S013 will occur. Output: MACRF=PM Each record must be prefixed by the RDW. CLOSE will write the last block. Each block written will have the BDW automatically inserted at the start. MACRF=W or RW Each block must be prefixed by the BDW.","title":"RECFM=VB Variable Blocked"},{"location":"file_services/#recfmft-fixed-ascii-text","text":"Translation: ASCII mode: None Non-ASCII mode input ASCII chars are translated to EBCDIC after being read. Non-ASCII mode output EBCDIC chars are translated to ASCII before being written, this is an internal function and does not affect the record in storage. Non-EBCDIC chars may be translated to X'00'. Input: The file is assumed to be in conventional ASCII format, with each record ending in the operating system specific end-of-line (EOL) character(s). EOL is never read as part of the record. If the record is shorter than LRECL, then trailing blanks are inserted. EODAD is invoked when all bytes have been read. Output: EOL is inserted at the end of each record after trailing blanks are stripped.","title":"RECFM=FT Fixed ASCII text"},{"location":"file_services/#recfmvt-variable-ascii-text","text":"Translation: ASCII mode None Non-ASCII mode input ASCII chars are translated to EBCDIC after being read. Non-ASCII mode output EBCDIC chars are translated to ASCII before being written. This is an internal function and does not affect the record in storage. Non-EBCDIC chars may be translated to X'00'. Input: The file is assumed to be in conventional ASCII format, with each record ending in the operating system specific end-of-line (EOL) character(s). EOL is never read as part of the record. Each record is prefixed with the RDW. EODAD is invoked when all bytes have been read. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. Output: Each record must be prefixed with the RDW. EOL is inserted at the end of each record after trailing blanks are stripped. Warning The RDW is not written.","title":"RECFM=VT Variable ASCII text"},{"location":"file_services/#record-record-address","text":"RECORD DSECT=DCBREC Type=A Default=0 (undefined) Default I/O area which can be overridden on the GET/PUT/READ/WRITE macros. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes If omitted, then the I/O area must be specified on the GET/PUT/READ/WRITE macros.","title":"RECORD - Record address"},{"location":"file_services/#lrecl-record-length","text":"LRECL DSECT=DCBLRECLF Type=F Default=0 Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes Maximum value is 2G-1. For RECFM=F or FB, sets the record size. For all other RECFM, sets the maximum record size. For RECFM=F, LRECL=0 is valid, provided that BLKSIZE is set. For RECFM=FB, LRECL must be a multiple of BLKSIZE. For variable records, include 4 for the RDW. The field DCBLRECL (Type=H) is retained for compatibility.","title":"LRECL - Record length"},{"location":"file_services/#blksize-block-size","text":"BLKSIZE DSECT=DCBBLKSIF Type=F Default=0 Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes Maximum value is 2G-1. LRECL and BLKSIZE cannot both be zero. For RECFM=F sets the record size if LRECL=0. For RECFM=FB, sets the block size and LRECL must be a multiple of BLKSIZE. For RECFM=VB, BLKSIZE must be at least 4 greater than LRECL. For all other RECFM, sets the maximum block size. The field DCBBLKSI (Type=H) is retained for compatibility.","title":"BLKSIZE - Block size"},{"location":"file_services/#DCB-DCBE-PARM","text":"DCBE DSECT=DCBDCBE Type=A Default=0 (undefined) The DCBE is a control block defined by the DCBE macro. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes When defined, the addresses of the end-of-file (EODAD) and the I/O error routine (SYNAD) may be defined. When set, these addresses override the DCB EODAD and SYNAD parameters. The DSECT IHADCBE maps the DCBE control block.","title":"DCBE - Data control block extension"},{"location":"file_services/#DCB-EODAD","text":"EODAD DSECT=DCBEODAD Type=Address Default=0 (no routine defined) The address of the end-of-file routine. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes This may be overridden if DCBE is coded. If a further GET is done after end-of-file, then the program is terminated.","title":"EODAD - End of file routine"},{"location":"file_services/#DCB-SYNAD","text":"SYNAD DSECT=DCBSYNAD Type=Address Default=0 (no routine defined) The address of the uncorrectable I/O error routine. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes This may be overridden if DCBE is coded.","title":"SYNAD - Error analysis routine"},{"location":"file_services/#dcbe-data-control-block-extended","text":"label DCBE EODAD=0,SYNAD=0,BLKSIZE=0","title":"DCBE - Data Control Block Extended"},{"location":"file_services/#eodad-end-of-data-routine-address","text":"Address of End of data routine. Default=0 = no routine When set, will override address provided in the DCB EODAD parameter.","title":"EODAD - End of data routine address"},{"location":"file_services/#synad-io-error-routine-address","text":"Address of IO Error routine. Default=0 - no routine When set, will override address provided in the DCB SYNAD parameter.","title":"SYNAD - IO error routine address"},{"location":"file_services/#blksize-large-block-interface","text":"Default is zero meaning Large Block support is not enabled. When set, the large block interface (LBI) is enabled. This causes BDW and RDW fields in variable length files to use an alternative format: LLLL where high bit is on and the remaining 31 bits are length.","title":"BLKSIZE - Large block interface"},{"location":"file_services/#dtfsd-vse-data-control-block","text":"VSE only DTFSD maps to the standard DCB as follows: label DTFSD BLKSIZE=n, X EOFADDR= label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0","title":"DTFSD (VSE) - Data control block"},{"location":"file_services/#dtfpr-vse-data-control-block","text":"VSE only DTFPR maps to the standard DCB as follows: label DTFPR BLKSIZE=n label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0","title":"DTFPR (VSE) - Data control block"},{"location":"file_services/#open-open-file","text":"Open one or more files.","title":"OPEN - Open file"},{"location":"file_services/#usage","text":"Open one file for INPUT OPEN dcbname Open one file for non-INPUT OPEN (dcbname,type) Open multiple files OPEN (dcbname1,type,dcbname2,type) The same, using register notation OPEN ((reg),type) OPEN ((reg1),type,(reg2),type)","title":"Usage"},{"location":"file_services/#registers","text":"R0 = Flags R1 = DCB addresses","title":"Registers"},{"location":"file_services/#abends","text":"S013 OPEN failed and no SYNAD exit provided","title":"Abends"},{"location":"file_services/#open-vse-open-file","text":"Open one or more files for UPDATE.","title":"OPEN (VSE) - Open file"},{"location":"file_services/#usage_1","text":"OPEN dtfname OPEN (dtfname1,dtfname2,...)","title":"Usage"},{"location":"file_services/#registers_1","text":"R0 = Flags R1 = DTF addresses","title":"Registers"},{"location":"file_services/#abends_1","text":"S013 OPEN failed and no SYNAD exit provided","title":"Abends"},{"location":"file_services/#close-close-file","text":"Close one or more files.","title":"CLOSE - Close file"},{"location":"file_services/#usage_2","text":"Close one file CLOSE dcbname Close multiple files CLOSE (dcbname1,,dcbname2) The same, using register notation CLOSE ((reg1),,(reg2))","title":"Usage"},{"location":"file_services/#registers_2","text":"R1 = DCB addresses","title":"Registers"},{"location":"file_services/#abends_2","text":"S013 CLOSE failed and no SYNAD exit provided","title":"Abends"},{"location":"file_services/#close-vse-close-file","text":"Close one or more files.","title":"CLOSE (VSE) - Close file"},{"location":"file_services/#usage_3","text":"CLOSE (dtfname1,dtfname2,...)","title":"Usage"},{"location":"file_services/#registers_3","text":"R1 = DTF addresses","title":"Registers"},{"location":"file_services/#abends_3","text":"S013 CLOSE failed and no SYNAD exit provided","title":"Abends"},{"location":"file_services/#get-read-sequential-record","text":"Read a sequential record","title":"GET - Read sequential record"},{"location":"file_services/#usage_4","text":"Read a record into an I/O area supplied on DCB RECORD=ioarea GET dcbname Read a record into an I/O area GET dcbname,ioarea The same, using register notation GET (reg) GET (reg1),(reg2)","title":"Usage"},{"location":"file_services/#registers_4","text":"R0 = ioarea R1 = DCB address","title":"Registers"},{"location":"file_services/#put-write-a-sequential-record","text":"Write a sequential record","title":"PUT - Write a sequential record"},{"location":"file_services/#usage_5","text":"Write a record from an I/O area supplied on the DCB RECORD=ioarea PUT dcbname Write a record from an I/O area PUT dcbname,ioarea The same, using register notation PUT (reg) PUT (reg1),(reg2)","title":"Usage"},{"location":"file_services/#registers_5","text":"R0 = ioarea R1 = DCB address","title":"Registers"},{"location":"file_services/#read-read-block-from-file","text":"Read a block from a file. If EODAD or SYNAD result from the READ, they will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB.","title":"READ - Read block from file"},{"location":"file_services/#usage_6","text":"Read a block using an internal DECB, into an I/O area supplied on the DCB RECORD=ioarea READ decbname,,dcbname Read a block using an internal DECB into an I/O area. The I/O area must be at least as large as DCB BLKSIZE READ decbname,,dcbname,ioarea The same, using register notation READ (reg1),,(reg2) READ (reg1),,(reg2),(reg3)","title":"Usage"},{"location":"file_services/#registers_6","text":"R0 = work register R1 = DECB address R15= DCB address","title":"Registers"},{"location":"file_services/#write-write-block-to-file","text":"Write a block to a file. If SYNAD results from the WRITE, it will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB.","title":"WRITE - Write block to file"},{"location":"file_services/#usage_7","text":"Write a block using an internal DECB, from an I/O area supplied on the DCB RECORD=ioarea WRITE decbname,,dcbname Write a block using an internal DECB from an I/O area WRITE decbname,,dcbname,ioarea The same, using register notation WRITE (reg1),,(reg2) WRITE (reg1),,(reg2),(reg3)","title":"Usage"},{"location":"file_services/#registers_7","text":"R0 = work register R1 = DECB address R15= DCB address","title":"Registers"},{"location":"file_services/#check-process-eodadsynad","text":"Process EODAD or SYNAD on READ. Process SYNAD on WRITE.","title":"CHECK - Process EODAD/SYNAD"},{"location":"file_services/#usage_8","text":"CHECK decbname The same, using register notation CHECK (reg)","title":"Usage"},{"location":"file_services/#registers_8","text":"R1 = DECB address","title":"Registers"},{"location":"file_services/#abends_4","text":"S013 READ/WRITE failed and no SYNAD exit provided","title":"Abends"},{"location":"file_services/#point-position-file-pointer","text":"Position pointer for next READ or WRITE When register notation is used for rba or rel, the register points to a field containing the value. rel is a fullword, maximum value 2,147,483,647 (2G - 1). rel is multiplied by BLKSIZE to get the rba. rba is signed 64-bit value.","title":"POINT - Position file pointer"},{"location":"file_services/#usage_9","text":"Point to a record using relative record number POINT dcbname,rel Point to a record using relative byte address POINT dcbname,,RBA=rba The same, using register notation POINT (reg1),(reg2) POINT (reg1),,RBA=(reg2)","title":"Usage"},{"location":"file_services/#registers_9","text":"R0 = rel or RBA R1 = DCB address R15= Blocksize","title":"Registers"},{"location":"file_services/#svc-functions","text":"The following is a list of the z390 SVC services that support the above macros. DEC HEX Service 19 13 OPEN 19 13 OPEN (VSE) 20 14 CLOSE 20 14 CLOSE (VSE) 151 97 GET 152 98 PUT 153 99 READ 154 9A WRITE 155 9B CHECK 156 9C POINT","title":"SVC functions"},{"location":"program_services/","text":"Program Services Save area and linkage conventions Standard save area is defined as follows: DS 0CL72 DS F +0 reserved DS F +4 address of calling savearea DS F +8 address of called savearea DS 15F +12 callers GR14 through GR12 There are normally two save areas involved when a program is called by another program: The save area for the calling program -- the caller The save area for the called program -- the callee Upon entry to the called program, GR13 contains the address of the caller's save area. The callee: Saves GR14 to GR12 (registers at entry to the called program) at +12 of the caller's save area Obtains its own save area (the called program's save area) Stores the address of its save area at +8 of the caller's save area (caller's forward chain) Stores the address of the caller's save area (GR13 at entry) at +4 of its (the called program's) save area (called program's back chain) Loads GR13 with the address of its (the called program's) save area At this point the called program begins its processing. If it calls another program steps 1--5 are repeated; this time the \"caller\" is the current program and there is a new called program. When the called program finishes processing, it returns to the caller as follows: The called program uses its back chain (+4 in its save area) to restore GR13 to caller's save area The called program restores GR14 to GR12 from that save area (restores registers at entry); there are cases when GR15, GR0, and/or GR1 are not restored -- depends on the program. The called program returns to the caller by doing an unconditional branch to the address in GR14. This calling convention is explained in detail in the IBM z/OS Version 2 Release 4 MVS Programming: Assembler Services Guide (SA23-1368-40) . Refer to Chapter 2 - Linkage conventions. GR15 by convention may contain a return code upon exit. Program parameters There are two methods of passing parameters to a program. At assembly time using SYSPARM At run time using PARM In either case enclose the entire parm to be passed in double quotes. The double quotes are required to handle commas and spaces that otherwise cause command processors to split the parm. The double quotes are not required if there are no commas or spaces in the text. Assembly time - SYSPARM If single quotes are included in text, they are passed on to &SYSPARM. There is a limit of 32767 bytes for the text. SYSPARM will be transferred to the macro variable &SYSPARM. mz390 ... \"SYSPARM(HELLO WORLD)\" Access the text by coding: label DC C'&SYSPARM' ...... will translate to label DC C'HELLO WORLD' Run time - PARM PARM can be accessed via GR1 at program entry. GR1 will contain an address that points to a fullword in storage which points to a storage location with the parm length in a halfword followed by the parm value. ez390 ... \"PARM(HELLO WORLD)\" The fullword pointed to by GR1 points to: DC H'11',C'HELLO WORLD'` If single quotes are included around text in PARM they are removed. ez390 ... \"PARM('HELLO WORLD')\" Will also result in the fullword pointed to by GR1 pointing to: DC H'11',C'HELLO WORLD'` Usage The program is run with the parameter passed ez390 myprog \"PARM('HELLO WORLD')\" The program code: L R2,0(,R1) R2=address of parm length(HW)+value LH R3,0(,R2) R3=length of parm value BCTR R3,0 Subtract 1 from R3 - length for use in machine code EX R3,MOVE Execute MOVE instruction using length code from R3 ...... MOVE MVC PARM(0),2(R2) Move instruction used by EX PARM DC CL80' ' Work area for parm value GR1 is populated by ez390 with the parm address pointer. GR2 is loaded with the address of the parm length and address - fullword pointed to by GR1. GR3 is loaded with the parm length - halfword value pointed to by GR2. GR3 would contain decimal 11 which is the length of the parm \"HELLO WORLD\". GR3 is decremented by 1, making it a length code. The actual parm value of \"HELLO WORLD\" begins 2 bytes past the address in GR2. The EX instruction executes the instruction at label MOVE which will move the parm to the storage at label PARM using the length code in R3. Macro reference BLDL - Build a directory list name BLDL 0,list Build a directory list for use with LOAD, DELETE, LINK and XCTL. After a BLDL, an individual table entry may be used in these macros via the DE= parameter. Parameters list May be a label or (reg) and points to a storage area in the following format: format description H'count' The number of entries in the table. The following data structure represents an entry. Data Storage description H'entry length' The length of the following entry CL8'name' The name of the program XL2'00' TT (unused) X'00' R (1=found) X'00' K (unused) X'00' Z (1=program found in storage) X'00' C (unused) Entry length must be a minimum of 12, which would omit the Z and C fields. Names must be in alphameric order, a suffix of .390 is assumed. Register Usage R1 = BLDL list R15= Return code Return Return code is passed in GR15: 0 - All programs found 4 - Some programs not found 8 - Invalid count or invalid entry length Usage BLDL 0,LIST1 LOAD DE=BLDL2 ...... LIST1 DC H'2' BLDL1 DC H'14',CL8'MYPROG1',XL6'00' BLDL2 DC H'14',CL8'MYPROG2',XL6'00' Note In z390, there is no performance benefit in issuing a BLDL before a LOAD, DELETE, LINK or XCTL. LOAD - Load a program or module name LOAD EP=,EPLOC=,DDNAME=,DSNAME=,DE=,LOADPT= Load a program or module. Parameters See Common Program load parameters . Register usage R0 = Pointer to program name or BLDL entry, returned address R1 = Returned length R15= Path pointer and return code Return GR0 returns the address of the loaded module. If LOADPT is used, then GR0 may be stored at a label, or the address contained in a general register. GR1 returns the length as follows: For a program, the number of doublewords (8-byte units). For other modules, the length rounded up to the next doubleword boundary. GR15 has a return code: 0 - Load ok 4 - Module not found Abends S80A - Out of memory CDLOAD - Load a program or module (VSE) name CDLOAD phasename Maps to LOAD EP=phasename name CDLOAD (reg) Maps to LOAD EPLOC=(reg) Load a program or module (VSE only). Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name, returned address R1 = Returned address R15= Return code Return GR0 and GR1 return the address of the loaded module. Length is not returned. GR15 has a return code: 0 - Load ok 4 - Module not found Abends S80A - Out of memory DELETE - Delete a program or module name DELETE EP=,EPLOC=,DDNAME=,DSNAME=,DE= Delete a program or module. Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name or BLDL entry R15= Path pointer Return GR15 has a return code: 0 - Load ok 4 - Module not found CDDELETE - Delete a program or module (VSE) name CDDELETE phasename Maps to DELETE EP=phasename name CDDELETE (reg) Maps to DELETE EPLOC=(reg) Delete a program or module. (VSE only) Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name Return GR15 has a return code: 0 - Load ok 4 - Module not found LINK - Load and pass control name LINK EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to 'linker'. Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name or BLDL entry R1 = Parameter list R15= Path pointer Abends S806 - Module not found S80A - Out of memory XCTL - Load and pass control name XCTL (fromreg,toreg),EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to last 'linker' or terminate. Parameters See Common Program load parameters . (fromreg,toreg) Optional - Restores the specified register range from the savearea pointed to by GR13. The registers are restored from their conventional positions. The range must not specify or include the following general registers: 0, 1, 13, 15 Register Usage R0 = Pointer to program name or BLDL entry R1 = Parameter list R15= Path pointer All registers in the range fromreg-toreg Abends S806 - Module not found S80A - Out of memory RESTORE - Restores registers name RESTORE (fromreg,toreg) Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions. Register Usage All registers in the range fromreg-toreg SNAP - Produces a component dump name SNAP STORAGE=(from,to),PDATA=(options, ... ),ID=,TEXT= Produces a component dump on the z390 console without terminating the program. Parameters STORAGE=(from,to) or STORAGE=((reg1),(reg2)) Optional parameter to dump some storage. Either 'from' or 'to' can be labels or register pointers. The first byte displayed is 'from' and the last is 'to'-1. PDATA=(options ... ) Optional parameter to display registers and/or control blocks. Default is PDATA=ALL . option description ALL Display all registers, control blocks and storage. When the STORAGE parameter is present only that area of storage is displayed. REGS Display all general and floating point registers. GPR Display general registers. FPR Display floating point registers. CDE Display information related to loaded programs or modules. DCB Display information related to opened and closed files. ID=nnnnn or ID=(reg) Numeric identifier, either numeric value or general register containing the identifier. Specify values 0-32767, higher values are negative. TEXT=string or TEXT='a string' or TEXT=(reg) Character identifier. Specify either a string without blanks, a string constant enclosed by single quotes or a general register pointing to a string terminated by X'00'. The string in all cases is limited to 60 bytes. Register Usage R0 = ID and flags R1 = TEXT pointer R14= STORAGE from R15= STORAGE to ABEND - Terminate program name ABEND id,DUMP Terminate the program. Parameters id Optional numeric identifier. Values from 0 to 4095. Displayed as abend Unnnn . DUMP A dump is always produced, overrides the NODUMP parm on ez390. All storage areas are dumped. Register Usage R1 = id and flags ESTAE, ESTAEX - Define Abend exit processing Info ESTAEX is provided for compatibility, only ESTAE is described here. name ESTAE label,type,PARAM= name ESTAE (reg),type,PARAM= name ESTAE 0 When a program abends, control is given to the label or address specified. Parameters 0 ESTAE 0 is used to cancel any previously established ESTAE routine. type Type is optional with default value of CT CT - adds a new exit OV - replaces an existing exit PARAM PARAM=label is optional PARAM=(reg) is optional When specified, the address of the label or the contents of the register are made available in the ESTAE control block at ESTAPARM. Exit invocation GR15 will contain the entry point, it is recommended that GR15 not be used as the base for the ESTAE routine. GR1 contains the address of the SDWA control block. The DSECT for the SDWA is generated by macro IHASDWA. This area may also be addressed by using the ZCVT. After processing the abend, several options are available: Cancel the exit and retry the failing instruction. Issue an ESTAE 0. Load GR0 with the address of the failing instruction, which is in the rightmost four bytes of the SDWA field SDWAEC1 and ensure that GR15=4, then return via BR R14. This will cancel the ESTAE and re-execute the instruction that caused the abend. If the instruction abends again, it will terminate the program. Sample code snippet: USING SDWA,R1 L R0,SDWAEC1+4 LA R15,4 BR R14 Enter a retry or cleanup routine. Place the retry address in GR0 and ensure GR15=4. If ESTAE 0 has not been issued, then the ESTAE routine remains active. Percolate through other recovery (ESTAE) routines. The current ESTAE routine is automatically cancelled. Set GR15=0 and return via BR R14. This will invoke previous recovery routines or abend the program. When percolate happens all LINK stack entries at a lower level than the latest ESTAE will be purged. Note In the z390 environment the abend code 0C5 may be caused by an internal error as well as a genuine addressing exception. If an abend occurs after the ESTAE exit is invoked and before ESTAE 0 or BR R14 are issued, then the program will be terminated. Register Usage R0 = exit address and flags R1 = parameter list R15= return code Return GR15 has a return code: 0 - ESTAE ok Abends SFFF - ESTAE stack exceeded ESPIE - Interrupt exit processing name ESPIE SET,addr,list,PARAM= name ESPIE SET,(reg),list,PARAM= name ESPIE RESET When a program interruption occurs eg. fixed point overflow, control is given to the label or address specified. Parameters RESET Will reset any previous ESPIE settings. list Set interupts that should be processed. If any of the codes 8, 10, 13 or 14 are specified, then the appropriate bit is set on in the PSW using the SPM instruction. The following interruption codes can appear in the list. 1 - operation 2 - privilege 3 - execute 4 - protection 5 - addressing 6 - specification 7 - data exception 8 - fixed point overflow (SPM mask bit X'8') 9 - fixed point divide 10 - decimal overflow (SPM mask bit X'4') 11 - decimal divide 12 - HFP exponent overflow 13 - HFP exponent underflow (SPM mask bit X'2') 14 - HFP significance (SPM mask bit X'1') 15 - HFP divide ESPIE SET,label,8 Single code ESPIE SET,label,(1,4,6) Multiple codes ESPIE SET,label,((2,6)) Range of codes: 2 through 6 ESPIE SET,label,(3,5,(7,9),14) Mixed codes: 3,5,7,8,9,14 PARAM (optional) PARAM=label PARAM=(reg) When specified the address of the label or the contents of the register are made available in the ESPIE control block. When the exit is invoked, GR1 contains the address of the EPIE control block. The macro IHAEPIE generates the DSECT for the EPIE. The EPIE control block is located in the ZCVT and may also be addressed by the ZCVT and EPIED macros. Note In the z390 environment, interruption code 5 may be caused by an internal error as well as a genuine addressing exception. Register Usage R0 = program mask R1 = exit address R15= parameter list SUBENTRY - Program entry name SUBENTRY CSECT=,BASES=,RENT=,RWA=,RWALNG=,STACK=,PSTACK=,PCHECK= Provides a standard entry for programs. Parameters name (optional) Although name is optional, care needs to be taken if it is omitted. A CSECT or sub-program should be named. CSECT= This is useful for setting up sub-programs within the main program that are invoked by the CALL macro. CSECT=YES (default) - Generates: name CSECT Standard entry. CSECT=NO - Generates: name DS 0D BASES= Override and extend the base registers for this program. Default BASES=(13) RENT Defines a re-entrant program. RENT=NO (default) A standard savearea is built, and GR13 is set as the default base register. This also serves as the pointer to the program's savearea to facilitate further linkage. The default base register GR13 may be overridden by the BASES= parameter (qv). It is recommended that the first register specified is GR13, if it isn't then a program is generated with non-standard linkage and may cause problems. RENT=YES The GETMAINed area described below is defined in the SUBENTRY macro. BASES= must be specified and the first register must not be GR13. Storage is GETMAINed and GR13 is set to the savearea within this storage. The STACK= parameter can generate multiple saveareas. The first register specified must NOT be 13. Each additional register generates the code and USING at the standard 4K intervals. eg. BASES=(13,7,8) will cover 12K of code. STACK=n Requires RENT=YES, default 0. Generates an addition to the GETMAINed area acquired allowing for multiple saveareas, each of these may have an additional read-only work area defined by RWALNG. RWA=dsectname (requires RENT=YES) RWA= defines the DSECT associated with this work area. RWALNG=n (requires RENT=YES, default 0) RWALNG defines the length of an additional work area to each savearea defined by STACK=. PSAVE Causes extra instructions to save and restore GR14 and GR15 registers. PSAVE=YES (default) - Save and restore GR14 and GR15 PSAVE=No - No save performed PSTACK=reg (requires RENT=YES, default=0) If PSTACK=0, then the user area address of each stack entry is stored at offset +80. Otherwise the user area address is not stored at offset +80, but loaded into the register specified. PCHECK (requires RENT=YES, default=YES) PCHECK=YES clears the stack area and sets the senior bit of the front and end pointers to 1. Register Usage R0,1,2,13,14,15 have multiple uses SUBEXIT - Program exit name SUBEXIT RC=returncode name SUBEXIT RC=(reg) Provides a standard exit for programs. If SUBENTRY used the parameter RENT=YES then the whole stack area will be FREEMAINed before GR15 is set. Parameters name (optional) RC will return the value in GR15, zero is the default. Register Usage All registers may be affected PERFORM or PM - Branch to local procedure name PERFORM procedure name PM procedure Generate a branch to a local procedure with base addressability. PERFORM and PM are identical macros. Uses MVC and B if SUBENTRY RENT=NO or push/pop stack if RENT=YES. Register Usage R14=Return address R15=Linkage register PENTRY - Define local procedure name PENTRY Define local procedure using name. Generates an entry-point for a local procedure preceded with a branch instruction if SUBENTRY RENT=NO. PEXIT - Exit local procedure name PEXIT Branch to last caller of local procedure. Generate branch to last PENTRY name address - 4. If SUBENTRY RENT=NO or generate decrement stack pointer, load, and branch if RENT=YES. Register Usage R14=Stack address R15=Saved linkage register EXIT - Return to last caller name EXIT Returns immediately to the last caller. No registers are restored. Use of SUBEXIT is preferred. Register Usage No registers affected EOJ (VSE only) name EOJ RC=returncode name EOJ RC=(reg) Returns immediately to the last caller. Parameters name is optional. RC will return the value in GR15, zero is the default. Register Usage R15= Return code CALL (list form) - Internal/external subroutine call name CALL ,(parm1,parm2,...),VL,MF=L Generates a parameter list for use with the execute form of CALL. name DC A(parm1,parm2...) Parameters (parm1,parm2,...) The parameters can be anything that is permitted in an A-type constant. Note that register forms like (R5) are not interpreted as general registers, but as constants. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. CALL (execute form) - Internal/external subroutine call name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=(E,parms) name CALL (reg),(parm1,parm2,...),VL,MF=(E,parms) Provides a standard internal or external subroutine call. Parameters Parameters are addressed by GR1 and linkage by GR14 routine. If a label, it can be internal (resolved at assembly time) or external (loaded and resolved by the linkage editor). If the routine is in register notation, it can be internal or separately loaded. (parm1,parm2,...) Modify a fixed or variable parameter list to be accessed by the called program. The parameter list must have initially been defined using the list form of the CALL. The parameters specified here will overlay that parameter list. It is important that the number of parameters specified here does not exceed those specified in the list form of the CALL. The parameters can be anything that is permitted in an A-type constant. Any parameters bounded by parentheses, eg. (R5) are assumed to be registers or register equates. The content of each register (fullword only) is stored at the parameter location. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. Note This is the last parameter in the modified parameter list. LINKINST= (optional) Determines the calling instruction. Choose BALR (default) or BASR. MF=(E,label) or MF=(E,(reg)) The label or register points to a parameter list previously defined with the list form of the CALL. Usage Call subroutine MYSUBR, replace the two parameters and mark the last parameter. MYCALL CALL MYSUBR,(8,MYDATA),VL,MF=(E,PARMS) ...... PARMS CALL ,(7,OLDDATA),VL,MF=L CALL (standard form) - Internal/external subroutine call name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=I name CALL (reg),(parm1,parm2,...),VL,LINKINST=,MF=I Provides a standard internal or external subroutine call. Parameters Parameters are addressed by GR1 and linkage by GR14 routine. If a label, it can be internal (resolved at assembly time) or external (loaded and resolved by the linkage editor). If the routine is in register notation, it can be internal or separately loaded. (parm1,parm2,...) (optional) Pass a fixed or variable parameter list to the called program. The parameters can be anything that is permitted in an A-type constant. Any parameters bounded by parentheses, eg. (R5) are assumed to be registers or register equates. The content of each register (fullword only) is stored at the parameter location. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. LINKINST= (optional) Determines the calling instruction. Choose BALR (default) or BASR. Usage Call subroutine MYSUBR, pass two parameters and mark the last parameter. MYCALL CALL MYSUBR,(8,MYDATA),VL Register Usage R0 = indirect parameter list R1 = parameter list R14= linkage R15= program location SAVE - Save registers name SAVE (fromreg,toreg) Saves the specified register range in the save area pointed to by GR13. The registers are saved in their conventional positions. RETURN - Restore registers name RETURN (fromreg,toreg),flag,RC= Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions. Return is by the restored GR14. Parameters flag (optional) T specifies that the byte at savearea+15 has the junior bit (bit 7) turned on to indicate a return to a called program. This bit (rightmost bit of saved GR14) is set after GR14 has been loaded with the return address. RC=nn or RC=(reg) If RC is omitted, GR15 is assumed to contain the return code. GR15 is loaded with this return code before returning via GR14. RC may have a numeric value or the value may be in GRreg. Register Usage R15= Return code All registers in the range fromreg-toreg Usage MYRET RETURN (14,12),T,RC=12 Restore registers 14 through 12. After the register restore, flag the savearea to indicate return to caller and set return code to 12. PSAD - PSA structure Provides a DSECT for the limited fields available in the first 8K of memory (PSA). The CVT may be addressed from here. ZCVTD - ZCVT structure Provides a DSECT for the limited fields available in the ZCVT. This follows the PSA and may be addressed as follows: L reg,ZCVT USING IHAZCVT,reg ...... ZCVTD CVTD - CVT structure Provides a DSECT for the limited fields available in the Communications Vector Table. This may be addressed as follows: L reg,X'10' USING IHACVT,reg ...... CVTD EQUREGS - Register equates EQUREGS REGS=option,TYPE=option Generates standard equates for the general or floating point registers. No parameters passed: EQUREGS (defaults to REGS=GPR,TYPE=DEC) R0 EQU 0 ...... R15 EQU 15 TYPE=HEX: EQUREGS TYPE=HEX R0 EQU 0 ...... RF EQU 15 REGS=FPR: EQUREGS REGS=FPR F0 EQU 0 ...... F15 EQU 15 REGS=FPR,TYPE=HEX EQUREGS REGS=FPR,TYPE=HEX F0 EQU 0 ...... FF EQU 15 YREGS - General register equates YREGS is identical to EQUREGS with default parameters which will generate general register equates. Additional information Use counts and parameter passing On the first invocation and after a LOAD , LINK or XCTL , the program receiving control has its use count incremented. When a program is DELETEd, it terminates or loses control via an XCTL, then the use count is decremented. When the use count is zero, the storage for that program is freed. When passing parameters it is important to consider whether those parameters are in a program whose storage may be reused. If in doubt, place parameters for passing on, in a separate GETMAINed area. Common program load parameters The following parameter descriptions apply to the LOAD , CDLOAD , DELETE , CDDELETE , LINK , XCTL and RESTORE macros. When a program is loaded (with suffix .390) then relocation takes place. EP, EPLOC, DDNAME and DSNAME are used to locate the program or module. EP, EPLOC and DE are mutually exclusive. DDNAME and DSNAME cannot both be present. EP=program Specify the program name, maximum 8 bytes. EPLOC=label or EPLOC=(reg) The label or the register must point to an 8-byte field containing the program name. DE=label or DE=(reg) The label or the register must point to a BLDL entry. In all the above cases as neither DDNAME nor DSNAME are specified, then the z390 search path is used. This may be overridden by the ez390 parameter SYS390. EP/EPLOC/DE and DDNAME=name or EP/EPLOC/DE and DDNAME=(reg) DDNAME has or points to the name of an environment variable. This variable may contain: The complete path and filename. In this case EP, EPLOC or DE are ignored. A single path. Only this path will be searched. Multiple paths separated by plus signs. All paths will be searched in the order specified. LINK EP=MYLINK,DDNAME=MYPATH ... For execution, define a script file setting the environment variable MYPATH Program specified with EP ignored SET MYPATH=c:\\path\\to\\390\\file.390 Single search path SET MYPATH=c:\\path\\to\\folder Multiple search paths SET MYPATH=c:\\path\\to\\dir1+c:\\path2 EP/EPLOC/DE and DSNAME=name or EP/EPLOC/DE and DSNAME=(reg) DSNAME is or points to a label defined in the program which has the file spec. The file spec must terminate with X'00' or be defined as a double-quoted string within the standard C-type constant. Either constant may contain: The complete path and filename. In this case EP, EPLOC or DE are ignored. A single path. Only this path will be searched. Multiple paths separated by semicolons or plus signs. All paths will be searched in the order specified. LINK EP=MYLINK,DSNAME=MYPATH ... ...... MYPATH DC C'c:\\path\\to\\file',X'00' MYPATH DC C'\"c:\\path1;c:\\path2\"' Note In the above cases where the filename is specified in the environment variable or the DC constant, then the .390 suffix should be omitted. The exceptions to this are LOAD and DELETE , which may be used to load or delete a non-program module and may have any suffix appended. PARAM= and VL= Only available on LINK and XCTL . Used for passing a fixed or variable parameter list to a program. PARAM=(parm1,parm2,...) The parameters can be anything that is permitted in an A-type constant. When the program is invoked GR1 points to the parameter list. See Use counts and parameter passing below for special considerations. VL=0 or VL=1 Default - VL=1 If the called program can accept a variable parameter list, then VL=1 will turn on the senior bit (bit 0) of the last parameter. SVC functions The following is a list of the z390 SVC services that support the macros. DEC HEX Service 3 03 EXIT 3 03 EXIT (VSE) 6 06 LINK 7 07 XCTL 8 08 LOAD 8 08 CDLOAD (VSE) 9 09 DELETE 9 09 CDDELETE (VSE) 13 0D ABEND","title":"Program Services"},{"location":"program_services/#program-services","text":"","title":"Program Services"},{"location":"program_services/#save-area-and-linkage-conventions","text":"Standard save area is defined as follows: DS 0CL72 DS F +0 reserved DS F +4 address of calling savearea DS F +8 address of called savearea DS 15F +12 callers GR14 through GR12 There are normally two save areas involved when a program is called by another program: The save area for the calling program -- the caller The save area for the called program -- the callee Upon entry to the called program, GR13 contains the address of the caller's save area. The callee: Saves GR14 to GR12 (registers at entry to the called program) at +12 of the caller's save area Obtains its own save area (the called program's save area) Stores the address of its save area at +8 of the caller's save area (caller's forward chain) Stores the address of the caller's save area (GR13 at entry) at +4 of its (the called program's) save area (called program's back chain) Loads GR13 with the address of its (the called program's) save area At this point the called program begins its processing. If it calls another program steps 1--5 are repeated; this time the \"caller\" is the current program and there is a new called program. When the called program finishes processing, it returns to the caller as follows: The called program uses its back chain (+4 in its save area) to restore GR13 to caller's save area The called program restores GR14 to GR12 from that save area (restores registers at entry); there are cases when GR15, GR0, and/or GR1 are not restored -- depends on the program. The called program returns to the caller by doing an unconditional branch to the address in GR14. This calling convention is explained in detail in the IBM z/OS Version 2 Release 4 MVS Programming: Assembler Services Guide (SA23-1368-40) . Refer to Chapter 2 - Linkage conventions. GR15 by convention may contain a return code upon exit.","title":"Save area and linkage conventions"},{"location":"program_services/#program-parameters","text":"There are two methods of passing parameters to a program. At assembly time using SYSPARM At run time using PARM In either case enclose the entire parm to be passed in double quotes. The double quotes are required to handle commas and spaces that otherwise cause command processors to split the parm. The double quotes are not required if there are no commas or spaces in the text.","title":"Program parameters"},{"location":"program_services/#assembly-time-sysparm","text":"If single quotes are included in text, they are passed on to &SYSPARM. There is a limit of 32767 bytes for the text. SYSPARM will be transferred to the macro variable &SYSPARM. mz390 ... \"SYSPARM(HELLO WORLD)\" Access the text by coding: label DC C'&SYSPARM' ...... will translate to label DC C'HELLO WORLD'","title":"Assembly time - SYSPARM"},{"location":"program_services/#run-time-parm","text":"PARM can be accessed via GR1 at program entry. GR1 will contain an address that points to a fullword in storage which points to a storage location with the parm length in a halfword followed by the parm value. ez390 ... \"PARM(HELLO WORLD)\" The fullword pointed to by GR1 points to: DC H'11',C'HELLO WORLD'` If single quotes are included around text in PARM they are removed. ez390 ... \"PARM('HELLO WORLD')\" Will also result in the fullword pointed to by GR1 pointing to: DC H'11',C'HELLO WORLD'`","title":"Run time - PARM"},{"location":"program_services/#usage","text":"The program is run with the parameter passed ez390 myprog \"PARM('HELLO WORLD')\" The program code: L R2,0(,R1) R2=address of parm length(HW)+value LH R3,0(,R2) R3=length of parm value BCTR R3,0 Subtract 1 from R3 - length for use in machine code EX R3,MOVE Execute MOVE instruction using length code from R3 ...... MOVE MVC PARM(0),2(R2) Move instruction used by EX PARM DC CL80' ' Work area for parm value GR1 is populated by ez390 with the parm address pointer. GR2 is loaded with the address of the parm length and address - fullword pointed to by GR1. GR3 is loaded with the parm length - halfword value pointed to by GR2. GR3 would contain decimal 11 which is the length of the parm \"HELLO WORLD\". GR3 is decremented by 1, making it a length code. The actual parm value of \"HELLO WORLD\" begins 2 bytes past the address in GR2. The EX instruction executes the instruction at label MOVE which will move the parm to the storage at label PARM using the length code in R3.","title":"Usage"},{"location":"program_services/#macro-reference","text":"","title":"Macro reference"},{"location":"program_services/#bldl-build-a-directory-list","text":"name BLDL 0,list Build a directory list for use with LOAD, DELETE, LINK and XCTL. After a BLDL, an individual table entry may be used in these macros via the DE= parameter.","title":"BLDL - Build a directory list"},{"location":"program_services/#parameters","text":"","title":"Parameters"},{"location":"program_services/#list","text":"May be a label or (reg) and points to a storage area in the following format: format description H'count' The number of entries in the table. The following data structure represents an entry. Data Storage description H'entry length' The length of the following entry CL8'name' The name of the program XL2'00' TT (unused) X'00' R (1=found) X'00' K (unused) X'00' Z (1=program found in storage) X'00' C (unused) Entry length must be a minimum of 12, which would omit the Z and C fields. Names must be in alphameric order, a suffix of .390 is assumed.","title":"list"},{"location":"program_services/#register-usage","text":"R1 = BLDL list R15= Return code","title":"Register Usage"},{"location":"program_services/#return","text":"Return code is passed in GR15: 0 - All programs found 4 - Some programs not found 8 - Invalid count or invalid entry length","title":"Return"},{"location":"program_services/#usage_1","text":"BLDL 0,LIST1 LOAD DE=BLDL2 ...... LIST1 DC H'2' BLDL1 DC H'14',CL8'MYPROG1',XL6'00' BLDL2 DC H'14',CL8'MYPROG2',XL6'00' Note In z390, there is no performance benefit in issuing a BLDL before a LOAD, DELETE, LINK or XCTL.","title":"Usage"},{"location":"program_services/#load-load-a-program-or-module","text":"name LOAD EP=,EPLOC=,DDNAME=,DSNAME=,DE=,LOADPT= Load a program or module.","title":"LOAD - Load a program or module"},{"location":"program_services/#parameters_1","text":"See Common Program load parameters .","title":"Parameters"},{"location":"program_services/#register-usage_1","text":"R0 = Pointer to program name or BLDL entry, returned address R1 = Returned length R15= Path pointer and return code","title":"Register usage"},{"location":"program_services/#return_1","text":"GR0 returns the address of the loaded module. If LOADPT is used, then GR0 may be stored at a label, or the address contained in a general register. GR1 returns the length as follows: For a program, the number of doublewords (8-byte units). For other modules, the length rounded up to the next doubleword boundary. GR15 has a return code: 0 - Load ok 4 - Module not found","title":"Return"},{"location":"program_services/#abends","text":"S80A - Out of memory","title":"Abends"},{"location":"program_services/#cdload-load-a-program-or-module-vse","text":"name CDLOAD phasename Maps to LOAD EP=phasename name CDLOAD (reg) Maps to LOAD EPLOC=(reg) Load a program or module (VSE only).","title":"CDLOAD - Load a program or module (VSE)"},{"location":"program_services/#parameters_2","text":"See Common Program load parameters .","title":"Parameters"},{"location":"program_services/#register-usage_2","text":"R0 = Pointer to program name, returned address R1 = Returned address R15= Return code","title":"Register Usage"},{"location":"program_services/#return_2","text":"GR0 and GR1 return the address of the loaded module. Length is not returned. GR15 has a return code: 0 - Load ok 4 - Module not found","title":"Return"},{"location":"program_services/#abends_1","text":"S80A - Out of memory","title":"Abends"},{"location":"program_services/#delete-delete-a-program-or-module","text":"name DELETE EP=,EPLOC=,DDNAME=,DSNAME=,DE= Delete a program or module.","title":"DELETE - Delete a program or module"},{"location":"program_services/#parameters_3","text":"See Common Program load parameters .","title":"Parameters"},{"location":"program_services/#register-usage_3","text":"R0 = Pointer to program name or BLDL entry R15= Path pointer","title":"Register Usage"},{"location":"program_services/#return_3","text":"GR15 has a return code: 0 - Load ok 4 - Module not found","title":"Return"},{"location":"program_services/#cddelete-delete-a-program-or-module-vse","text":"name CDDELETE phasename Maps to DELETE EP=phasename name CDDELETE (reg) Maps to DELETE EPLOC=(reg) Delete a program or module. (VSE only)","title":"CDDELETE - Delete a program or module (VSE)"},{"location":"program_services/#parameters_4","text":"See Common Program load parameters .","title":"Parameters"},{"location":"program_services/#register-usage_4","text":"R0 = Pointer to program name","title":"Register Usage"},{"location":"program_services/#return_4","text":"GR15 has a return code: 0 - Load ok 4 - Module not found","title":"Return"},{"location":"program_services/#link-load-and-pass-control","text":"name LINK EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to 'linker'.","title":"LINK - Load and pass control"},{"location":"program_services/#parameters_5","text":"See Common Program load parameters .","title":"Parameters"},{"location":"program_services/#register-usage_5","text":"R0 = Pointer to program name or BLDL entry R1 = Parameter list R15= Path pointer","title":"Register Usage"},{"location":"program_services/#abends_2","text":"S806 - Module not found S80A - Out of memory","title":"Abends"},{"location":"program_services/#xctl-load-and-pass-control","text":"name XCTL (fromreg,toreg),EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to last 'linker' or terminate.","title":"XCTL - Load and pass control"},{"location":"program_services/#parameters_6","text":"See Common Program load parameters . (fromreg,toreg) Optional - Restores the specified register range from the savearea pointed to by GR13. The registers are restored from their conventional positions. The range must not specify or include the following general registers: 0, 1, 13, 15","title":"Parameters"},{"location":"program_services/#register-usage_6","text":"R0 = Pointer to program name or BLDL entry R1 = Parameter list R15= Path pointer All registers in the range fromreg-toreg","title":"Register Usage"},{"location":"program_services/#abends_3","text":"S806 - Module not found S80A - Out of memory","title":"Abends"},{"location":"program_services/#restore-restores-registers","text":"name RESTORE (fromreg,toreg) Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions.","title":"RESTORE - Restores registers"},{"location":"program_services/#register-usage_7","text":"All registers in the range fromreg-toreg","title":"Register Usage"},{"location":"program_services/#snap-produces-a-component-dump","text":"name SNAP STORAGE=(from,to),PDATA=(options, ... ),ID=,TEXT= Produces a component dump on the z390 console without terminating the program.","title":"SNAP - Produces a component dump"},{"location":"program_services/#parameters_7","text":"STORAGE=(from,to) or STORAGE=((reg1),(reg2)) Optional parameter to dump some storage. Either 'from' or 'to' can be labels or register pointers. The first byte displayed is 'from' and the last is 'to'-1. PDATA=(options ... ) Optional parameter to display registers and/or control blocks. Default is PDATA=ALL . option description ALL Display all registers, control blocks and storage. When the STORAGE parameter is present only that area of storage is displayed. REGS Display all general and floating point registers. GPR Display general registers. FPR Display floating point registers. CDE Display information related to loaded programs or modules. DCB Display information related to opened and closed files. ID=nnnnn or ID=(reg) Numeric identifier, either numeric value or general register containing the identifier. Specify values 0-32767, higher values are negative. TEXT=string or TEXT='a string' or TEXT=(reg) Character identifier. Specify either a string without blanks, a string constant enclosed by single quotes or a general register pointing to a string terminated by X'00'. The string in all cases is limited to 60 bytes.","title":"Parameters"},{"location":"program_services/#register-usage_8","text":"R0 = ID and flags R1 = TEXT pointer R14= STORAGE from R15= STORAGE to","title":"Register Usage"},{"location":"program_services/#abend-terminate-program","text":"name ABEND id,DUMP Terminate the program.","title":"ABEND - Terminate program"},{"location":"program_services/#parameters_8","text":"id Optional numeric identifier. Values from 0 to 4095. Displayed as abend Unnnn . DUMP A dump is always produced, overrides the NODUMP parm on ez390. All storage areas are dumped.","title":"Parameters"},{"location":"program_services/#register-usage_9","text":"R1 = id and flags","title":"Register Usage"},{"location":"program_services/#estae-estaex-define-abend-exit-processing","text":"Info ESTAEX is provided for compatibility, only ESTAE is described here. name ESTAE label,type,PARAM= name ESTAE (reg),type,PARAM= name ESTAE 0 When a program abends, control is given to the label or address specified.","title":"ESTAE, ESTAEX - Define Abend exit processing"},{"location":"program_services/#parameters_9","text":"0 ESTAE 0 is used to cancel any previously established ESTAE routine. type Type is optional with default value of CT CT - adds a new exit OV - replaces an existing exit PARAM PARAM=label is optional PARAM=(reg) is optional When specified, the address of the label or the contents of the register are made available in the ESTAE control block at ESTAPARM.","title":"Parameters"},{"location":"program_services/#exit-invocation","text":"GR15 will contain the entry point, it is recommended that GR15 not be used as the base for the ESTAE routine. GR1 contains the address of the SDWA control block. The DSECT for the SDWA is generated by macro IHASDWA. This area may also be addressed by using the ZCVT. After processing the abend, several options are available: Cancel the exit and retry the failing instruction. Issue an ESTAE 0. Load GR0 with the address of the failing instruction, which is in the rightmost four bytes of the SDWA field SDWAEC1 and ensure that GR15=4, then return via BR R14. This will cancel the ESTAE and re-execute the instruction that caused the abend. If the instruction abends again, it will terminate the program. Sample code snippet: USING SDWA,R1 L R0,SDWAEC1+4 LA R15,4 BR R14 Enter a retry or cleanup routine. Place the retry address in GR0 and ensure GR15=4. If ESTAE 0 has not been issued, then the ESTAE routine remains active. Percolate through other recovery (ESTAE) routines. The current ESTAE routine is automatically cancelled. Set GR15=0 and return via BR R14. This will invoke previous recovery routines or abend the program. When percolate happens all LINK stack entries at a lower level than the latest ESTAE will be purged. Note In the z390 environment the abend code 0C5 may be caused by an internal error as well as a genuine addressing exception. If an abend occurs after the ESTAE exit is invoked and before ESTAE 0 or BR R14 are issued, then the program will be terminated.","title":"Exit invocation"},{"location":"program_services/#register-usage_10","text":"R0 = exit address and flags R1 = parameter list R15= return code","title":"Register Usage"},{"location":"program_services/#return_5","text":"GR15 has a return code: 0 - ESTAE ok","title":"Return"},{"location":"program_services/#abends_4","text":"SFFF - ESTAE stack exceeded","title":"Abends"},{"location":"program_services/#espie-interrupt-exit-processing","text":"name ESPIE SET,addr,list,PARAM= name ESPIE SET,(reg),list,PARAM= name ESPIE RESET When a program interruption occurs eg. fixed point overflow, control is given to the label or address specified.","title":"ESPIE - Interrupt exit processing"},{"location":"program_services/#parameters_10","text":"RESET Will reset any previous ESPIE settings. list Set interupts that should be processed. If any of the codes 8, 10, 13 or 14 are specified, then the appropriate bit is set on in the PSW using the SPM instruction. The following interruption codes can appear in the list. 1 - operation 2 - privilege 3 - execute 4 - protection 5 - addressing 6 - specification 7 - data exception 8 - fixed point overflow (SPM mask bit X'8') 9 - fixed point divide 10 - decimal overflow (SPM mask bit X'4') 11 - decimal divide 12 - HFP exponent overflow 13 - HFP exponent underflow (SPM mask bit X'2') 14 - HFP significance (SPM mask bit X'1') 15 - HFP divide ESPIE SET,label,8 Single code ESPIE SET,label,(1,4,6) Multiple codes ESPIE SET,label,((2,6)) Range of codes: 2 through 6 ESPIE SET,label,(3,5,(7,9),14) Mixed codes: 3,5,7,8,9,14 PARAM (optional) PARAM=label PARAM=(reg) When specified the address of the label or the contents of the register are made available in the ESPIE control block. When the exit is invoked, GR1 contains the address of the EPIE control block. The macro IHAEPIE generates the DSECT for the EPIE. The EPIE control block is located in the ZCVT and may also be addressed by the ZCVT and EPIED macros. Note In the z390 environment, interruption code 5 may be caused by an internal error as well as a genuine addressing exception.","title":"Parameters"},{"location":"program_services/#register-usage_11","text":"R0 = program mask R1 = exit address R15= parameter list","title":"Register Usage"},{"location":"program_services/#subentry-program-entry","text":"name SUBENTRY CSECT=,BASES=,RENT=,RWA=,RWALNG=,STACK=,PSTACK=,PCHECK= Provides a standard entry for programs.","title":"SUBENTRY - Program entry"},{"location":"program_services/#parameters_11","text":"name (optional) Although name is optional, care needs to be taken if it is omitted. A CSECT or sub-program should be named. CSECT= This is useful for setting up sub-programs within the main program that are invoked by the CALL macro. CSECT=YES (default) - Generates: name CSECT Standard entry. CSECT=NO - Generates: name DS 0D BASES= Override and extend the base registers for this program. Default BASES=(13) RENT Defines a re-entrant program. RENT=NO (default) A standard savearea is built, and GR13 is set as the default base register. This also serves as the pointer to the program's savearea to facilitate further linkage. The default base register GR13 may be overridden by the BASES= parameter (qv). It is recommended that the first register specified is GR13, if it isn't then a program is generated with non-standard linkage and may cause problems. RENT=YES The GETMAINed area described below is defined in the SUBENTRY macro. BASES= must be specified and the first register must not be GR13. Storage is GETMAINed and GR13 is set to the savearea within this storage. The STACK= parameter can generate multiple saveareas. The first register specified must NOT be 13. Each additional register generates the code and USING at the standard 4K intervals. eg. BASES=(13,7,8) will cover 12K of code. STACK=n Requires RENT=YES, default 0. Generates an addition to the GETMAINed area acquired allowing for multiple saveareas, each of these may have an additional read-only work area defined by RWALNG. RWA=dsectname (requires RENT=YES) RWA= defines the DSECT associated with this work area. RWALNG=n (requires RENT=YES, default 0) RWALNG defines the length of an additional work area to each savearea defined by STACK=. PSAVE Causes extra instructions to save and restore GR14 and GR15 registers. PSAVE=YES (default) - Save and restore GR14 and GR15 PSAVE=No - No save performed PSTACK=reg (requires RENT=YES, default=0) If PSTACK=0, then the user area address of each stack entry is stored at offset +80. Otherwise the user area address is not stored at offset +80, but loaded into the register specified. PCHECK (requires RENT=YES, default=YES) PCHECK=YES clears the stack area and sets the senior bit of the front and end pointers to 1.","title":"Parameters"},{"location":"program_services/#register-usage_12","text":"R0,1,2,13,14,15 have multiple uses","title":"Register Usage"},{"location":"program_services/#subexit-program-exit","text":"name SUBEXIT RC=returncode name SUBEXIT RC=(reg) Provides a standard exit for programs. If SUBENTRY used the parameter RENT=YES then the whole stack area will be FREEMAINed before GR15 is set.","title":"SUBEXIT - Program exit"},{"location":"program_services/#parameters_12","text":"name (optional) RC will return the value in GR15, zero is the default.","title":"Parameters"},{"location":"program_services/#register-usage_13","text":"All registers may be affected","title":"Register Usage"},{"location":"program_services/#perform-or-pm-branch-to-local-procedure","text":"name PERFORM procedure name PM procedure Generate a branch to a local procedure with base addressability. PERFORM and PM are identical macros. Uses MVC and B if SUBENTRY RENT=NO or push/pop stack if RENT=YES.","title":"PERFORM or PM - Branch to local procedure"},{"location":"program_services/#register-usage_14","text":"R14=Return address R15=Linkage register","title":"Register Usage"},{"location":"program_services/#pentry-define-local-procedure","text":"name PENTRY Define local procedure using name. Generates an entry-point for a local procedure preceded with a branch instruction if SUBENTRY RENT=NO.","title":"PENTRY - Define local procedure"},{"location":"program_services/#pexit-exit-local-procedure","text":"name PEXIT Branch to last caller of local procedure. Generate branch to last PENTRY name address - 4. If SUBENTRY RENT=NO or generate decrement stack pointer, load, and branch if RENT=YES.","title":"PEXIT - Exit local procedure"},{"location":"program_services/#register-usage_15","text":"R14=Stack address R15=Saved linkage register","title":"Register Usage"},{"location":"program_services/#exit-return-to-last-caller","text":"name EXIT Returns immediately to the last caller. No registers are restored. Use of SUBEXIT is preferred.","title":"EXIT - Return to last caller"},{"location":"program_services/#register-usage_16","text":"No registers affected","title":"Register Usage"},{"location":"program_services/#eoj-vse-only","text":"name EOJ RC=returncode name EOJ RC=(reg) Returns immediately to the last caller.","title":"EOJ (VSE only)"},{"location":"program_services/#parameters_13","text":"name is optional. RC will return the value in GR15, zero is the default.","title":"Parameters"},{"location":"program_services/#register-usage_17","text":"R15= Return code","title":"Register Usage"},{"location":"program_services/#call-list-form-internalexternal-subroutine-call","text":"name CALL ,(parm1,parm2,...),VL,MF=L Generates a parameter list for use with the execute form of CALL. name DC A(parm1,parm2...)","title":"CALL (list form) - Internal/external subroutine call"},{"location":"program_services/#parameters_14","text":"(parm1,parm2,...) The parameters can be anything that is permitted in an A-type constant. Note that register forms like (R5) are not interpreted as general registers, but as constants. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter.","title":"Parameters"},{"location":"program_services/#call-execute-form-internalexternal-subroutine-call","text":"name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=(E,parms) name CALL (reg),(parm1,parm2,...),VL,MF=(E,parms) Provides a standard internal or external subroutine call.","title":"CALL (execute form) - Internal/external subroutine call"},{"location":"program_services/#parameters_15","text":"Parameters are addressed by GR1 and linkage by GR14 routine. If a label, it can be internal (resolved at assembly time) or external (loaded and resolved by the linkage editor). If the routine is in register notation, it can be internal or separately loaded. (parm1,parm2,...) Modify a fixed or variable parameter list to be accessed by the called program. The parameter list must have initially been defined using the list form of the CALL. The parameters specified here will overlay that parameter list. It is important that the number of parameters specified here does not exceed those specified in the list form of the CALL. The parameters can be anything that is permitted in an A-type constant. Any parameters bounded by parentheses, eg. (R5) are assumed to be registers or register equates. The content of each register (fullword only) is stored at the parameter location. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. Note This is the last parameter in the modified parameter list. LINKINST= (optional) Determines the calling instruction. Choose BALR (default) or BASR. MF=(E,label) or MF=(E,(reg)) The label or register points to a parameter list previously defined with the list form of the CALL.","title":"Parameters"},{"location":"program_services/#usage_2","text":"Call subroutine MYSUBR, replace the two parameters and mark the last parameter. MYCALL CALL MYSUBR,(8,MYDATA),VL,MF=(E,PARMS) ...... PARMS CALL ,(7,OLDDATA),VL,MF=L","title":"Usage"},{"location":"program_services/#call-standard-form-internalexternal-subroutine-call","text":"name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=I name CALL (reg),(parm1,parm2,...),VL,LINKINST=,MF=I Provides a standard internal or external subroutine call.","title":"CALL (standard form) - Internal/external subroutine call"},{"location":"program_services/#parameters_16","text":"Parameters are addressed by GR1 and linkage by GR14 routine. If a label, it can be internal (resolved at assembly time) or external (loaded and resolved by the linkage editor). If the routine is in register notation, it can be internal or separately loaded. (parm1,parm2,...) (optional) Pass a fixed or variable parameter list to the called program. The parameters can be anything that is permitted in an A-type constant. Any parameters bounded by parentheses, eg. (R5) are assumed to be registers or register equates. The content of each register (fullword only) is stored at the parameter location. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. LINKINST= (optional) Determines the calling instruction. Choose BALR (default) or BASR.","title":"Parameters"},{"location":"program_services/#usage_3","text":"Call subroutine MYSUBR, pass two parameters and mark the last parameter. MYCALL CALL MYSUBR,(8,MYDATA),VL","title":"Usage"},{"location":"program_services/#register-usage_18","text":"R0 = indirect parameter list R1 = parameter list R14= linkage R15= program location","title":"Register Usage"},{"location":"program_services/#save-save-registers","text":"name SAVE (fromreg,toreg) Saves the specified register range in the save area pointed to by GR13. The registers are saved in their conventional positions.","title":"SAVE - Save registers"},{"location":"program_services/#return-restore-registers","text":"name RETURN (fromreg,toreg),flag,RC= Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions. Return is by the restored GR14.","title":"RETURN - Restore registers"},{"location":"program_services/#parameters_17","text":"flag (optional) T specifies that the byte at savearea+15 has the junior bit (bit 7) turned on to indicate a return to a called program. This bit (rightmost bit of saved GR14) is set after GR14 has been loaded with the return address. RC=nn or RC=(reg) If RC is omitted, GR15 is assumed to contain the return code. GR15 is loaded with this return code before returning via GR14. RC may have a numeric value or the value may be in GRreg.","title":"Parameters"},{"location":"program_services/#register-usage_19","text":"R15= Return code All registers in the range fromreg-toreg","title":"Register Usage"},{"location":"program_services/#usage_4","text":"MYRET RETURN (14,12),T,RC=12 Restore registers 14 through 12. After the register restore, flag the savearea to indicate return to caller and set return code to 12.","title":"Usage"},{"location":"program_services/#psad-psa-structure","text":"Provides a DSECT for the limited fields available in the first 8K of memory (PSA). The CVT may be addressed from here.","title":"PSAD - PSA structure"},{"location":"program_services/#zcvtd-zcvt-structure","text":"Provides a DSECT for the limited fields available in the ZCVT. This follows the PSA and may be addressed as follows: L reg,ZCVT USING IHAZCVT,reg ...... ZCVTD","title":"ZCVTD - ZCVT structure"},{"location":"program_services/#cvtd-cvt-structure","text":"Provides a DSECT for the limited fields available in the Communications Vector Table. This may be addressed as follows: L reg,X'10' USING IHACVT,reg ...... CVTD","title":"CVTD - CVT structure"},{"location":"program_services/#equregs-register-equates","text":"EQUREGS REGS=option,TYPE=option Generates standard equates for the general or floating point registers. No parameters passed: EQUREGS (defaults to REGS=GPR,TYPE=DEC) R0 EQU 0 ...... R15 EQU 15 TYPE=HEX: EQUREGS TYPE=HEX R0 EQU 0 ...... RF EQU 15 REGS=FPR: EQUREGS REGS=FPR F0 EQU 0 ...... F15 EQU 15 REGS=FPR,TYPE=HEX EQUREGS REGS=FPR,TYPE=HEX F0 EQU 0 ...... FF EQU 15","title":"EQUREGS - Register equates"},{"location":"program_services/#yregs-general-register-equates","text":"YREGS is identical to EQUREGS with default parameters which will generate general register equates.","title":"YREGS - General register equates"},{"location":"program_services/#additional-information","text":"","title":"Additional information"},{"location":"program_services/#use-counts-and-parameter-passing","text":"On the first invocation and after a LOAD , LINK or XCTL , the program receiving control has its use count incremented. When a program is DELETEd, it terminates or loses control via an XCTL, then the use count is decremented. When the use count is zero, the storage for that program is freed. When passing parameters it is important to consider whether those parameters are in a program whose storage may be reused. If in doubt, place parameters for passing on, in a separate GETMAINed area.","title":"Use counts and parameter passing"},{"location":"program_services/#common-program-load-parameters","text":"The following parameter descriptions apply to the LOAD , CDLOAD , DELETE , CDDELETE , LINK , XCTL and RESTORE macros. When a program is loaded (with suffix .390) then relocation takes place. EP, EPLOC, DDNAME and DSNAME are used to locate the program or module. EP, EPLOC and DE are mutually exclusive. DDNAME and DSNAME cannot both be present.","title":"Common program load parameters"},{"location":"program_services/#epprogram","text":"Specify the program name, maximum 8 bytes.","title":"EP=program"},{"location":"program_services/#eploclabel-or-eplocreg","text":"The label or the register must point to an 8-byte field containing the program name.","title":"EPLOC=label or EPLOC=(reg)"},{"location":"program_services/#delabel-or-dereg","text":"The label or the register must point to a BLDL entry. In all the above cases as neither DDNAME nor DSNAME are specified, then the z390 search path is used. This may be overridden by the ez390 parameter SYS390.","title":"DE=label or DE=(reg)"},{"location":"program_services/#epeplocde-and-ddnamename-or-epeplocde-and-ddnamereg","text":"DDNAME has or points to the name of an environment variable. This variable may contain: The complete path and filename. In this case EP, EPLOC or DE are ignored. A single path. Only this path will be searched. Multiple paths separated by plus signs. All paths will be searched in the order specified. LINK EP=MYLINK,DDNAME=MYPATH ... For execution, define a script file setting the environment variable MYPATH Program specified with EP ignored SET MYPATH=c:\\path\\to\\390\\file.390 Single search path SET MYPATH=c:\\path\\to\\folder Multiple search paths SET MYPATH=c:\\path\\to\\dir1+c:\\path2","title":"EP/EPLOC/DE and DDNAME=name or EP/EPLOC/DE and DDNAME=(reg)"},{"location":"program_services/#epeplocde-and-dsnamename-or-epeplocde-and-dsnamereg","text":"DSNAME is or points to a label defined in the program which has the file spec. The file spec must terminate with X'00' or be defined as a double-quoted string within the standard C-type constant. Either constant may contain: The complete path and filename. In this case EP, EPLOC or DE are ignored. A single path. Only this path will be searched. Multiple paths separated by semicolons or plus signs. All paths will be searched in the order specified. LINK EP=MYLINK,DSNAME=MYPATH ... ...... MYPATH DC C'c:\\path\\to\\file',X'00' MYPATH DC C'\"c:\\path1;c:\\path2\"' Note In the above cases where the filename is specified in the environment variable or the DC constant, then the .390 suffix should be omitted. The exceptions to this are LOAD and DELETE , which may be used to load or delete a non-program module and may have any suffix appended.","title":"EP/EPLOC/DE and DSNAME=name or EP/EPLOC/DE and DSNAME=(reg)"},{"location":"program_services/#param-and-vl","text":"Only available on LINK and XCTL . Used for passing a fixed or variable parameter list to a program. PARAM=(parm1,parm2,...) The parameters can be anything that is permitted in an A-type constant. When the program is invoked GR1 points to the parameter list. See Use counts and parameter passing below for special considerations.","title":"PARAM= and VL="},{"location":"program_services/#vl0-or-vl1","text":"Default - VL=1 If the called program can accept a variable parameter list, then VL=1 will turn on the senior bit (bit 0) of the last parameter.","title":"VL=0 or VL=1"},{"location":"program_services/#svc-functions","text":"The following is a list of the z390 SVC services that support the macros. DEC HEX Service 3 03 EXIT 3 03 EXIT (VSE) 6 06 LINK 7 07 XCTL 8 08 LOAD 8 08 CDLOAD (VSE) 9 09 DELETE 9 09 CDDELETE (VSE) 13 0D ABEND","title":"SVC functions"},{"location":"svc_services/","text":"SVC services Macro reference TIME(SVC) - Obtain the time and date name TIME type,addr,LINKAGE=SVC,DATETYPE=,CLOCKTYPE= Obtain the time and/or date in various formats. Parameters Type DEC - Decimal name TIME name TIME DEC Returns: Time in GR0 as HHMMSSTH Hours, mins and secs to 2 decimal places. The values are unsigned packed decimal: X'21420654' = 21:42:06.54 The MVO instruction can be used after storing the register to convert it to standard packed decimal format. Date in GR1 as CCYYDDDF - Century, year, day number and sign. The values are signed decimal: CC is (almost) the century number. YY the year number. DDD the day number within the year. F the positive sign. X'0106003F' = 3rd January 2006 After storing, AP DATE,=P'1900000' can be used to convert to a 4-digit year. BIN - Binary name TIME BIN Returns: Time in GR0 in hundredths of a second since midnight in binary. Date in GR1 as CCYYDDDF - Century, year, day number and sign. TU - Time units name TIME TU Returns: Time in GR0 in timer units of 26.04166\u00b5s since midnight in binary. Date in GR1 as CCYYDDDF - Century, year, day number and sign. INS - Instruction count name TIME INS Returns: Instruction count in GR1 (64 bit value). MIC - Microseconds name TIME MIC,label name TIME MIC,(reg) Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified. Date in GR1 as CCYYDDDF - Century, year, day number and sign. NS - Nanoseconds name TIME NS,label name TIME NS,(reg) Returns: Time in units of 1ns in binary since midnight. The time is stored at the 8 bytes specified. STCK - Microseconds bits 0-51 name TIME STCK,label name TIME STCK,(reg) Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. Date in GR1 as above. TS - Timestamp name TIME TS,label name TIME TS,(reg) Returns: A string of 29 bytes at the label or pointed to by reg. The format is \"YYYY-MM-DD HH:MM:SS.NNNNNNNNN\". CLOCK - Microseconds since 1/1/1900 CLOCKTYPE=STCK name TIME CLOCK,label,CLOCKTYPE=STCK name TIME CLOCK,(reg),CLOCKTYPE=STCK Returns: Time in units of 1\u00b5s in binary since 1st January 1900. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. CLOCKTYPE=STCKE name TIME CLOCK,label,CLOCKTYPE=STCKE name TIME CLOCK,(reg),CLOCKTYPE=STCKE Returns: Time in units of 1\u00b5s in binary since 1st January 1900. The time is stored at the 16 bytes specified: Byte 0 : Zero Bytes 1-13 : The time Bytes 14-15 : Programmable field set by the SCKPF instruction and not currently implemented. The time uses only bits 8-111 of the 16-byte field with bits 8-59 being the value in microseconds. CLOCKTYPE=JAVA name TIME CLOCK,label,CLOCKTYPE=JAVA name TIME CLOCK,(reg),CLOCKTYPE=JAVA Returns: Time in units of 1ms in binary since 1st January 1970. The time is stored at the 8 bytes specified. Register Usage R0 = Code for units and date type R1 = Result area Return GR15 has a return code: 0 - TIME ok 4 - Invalid request TIME(SYSTEM) - Obtain the time and date name TIME type,addr,LINKAGE=SYSTEM,DATETYPE=,CLOCKTYPE= Parameters DATETYPE Specify the date format returned. All the formats are 4 bytes and the values are unsigned packed decimal. The MVO instruction can be used to convert it to standard packed decimal format. YYYY the year number. DDD the day number within the year. DD the day number within the month. MM the month number. YYYYDDD (default) stored as 0YYYYDDD MMDDYYYY DDMMYYYY YYYYMMDD Type DEC - Decimal name TIME ,label,LINKAGE=SYSTEM name TIME ,(reg),LINKAGE=SYSTEM name TIME DEC,label,LINKAGE=SYSTEM name TIME DEC,(reg),LINKAGE=SYSTEM Returns: Time as HHMMSSTH The time is stored at the 4 bytes specified. Hours, mins and secs to 2 decimal places. The values are unsigned packed decimal: X'21420654' = 21:42:06.54 The MVO instruction can be used to convert it to standard packed decimal format. The date is stored at label+8 or 8(reg). BIN - Binary name TIME BIN,label,LINKAGE=SYSTEM name TIME BIN,(reg),LINKAGE=SYSTEM Returns: The time is stored at the 4 bytes specified in hundredths of a second since midnight The date is stored at label+8 or 8(reg). MIC - Microseconds name TIME MIC,label,LINKAGE=SYSTEM name TIME MIC,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified. The date is stored at label+8 or 8(reg). STCK - Microseconds 0-51 bits only name TIME STCK,label.LINKAGE=SYSTEM name TIME STCK,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. The date is stored at label+8 or 8(reg). STCKE - Microseconds 16 byte name TIME STCKE,label.LINKAGE=SYSTEM name TIME STCKE,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 16 bytes specified: Byte 0 : Zero Bytes 1-13 : The time Bytes 14-15 : Programmable field set by the SCKPF instruction and not currently implemented. The time uses only bits 8-111 of the 16-byte field with bits 8-59 being the value in microseconds. Note The DATETYPE parameter is ignored. Register Usage R0 = Code for units and date type R1 = Result area Return GR15 has a return code: 0 - TIME ok 4 - Invalid request GETIME - Obtain time and date (VSE) GETIME type Obtain the time in various formats (VSE only). The time is stored in the GR0/GR1 register pair. Parameters type - date type STANDARD (default) Time in GR1 as 0HHMMSSc . Hours, mins and secs in packed format. BIN - Binary Time in GR1 in seconds since midnight in binary. TU - Time unit Time in GR1 in timer units of 26.04166\u00b5s since midnight in binary. MIC - Microseconds Time in units of 1\u00b5s in binary since midnight. Return GR15 has a return code: 0 - GETIME ok 4 - Invalid request STIMER - Wait for an interval of time Wait for an interval of time. name STIMER WAIT,BINTVL=label name STIMER WAIT,DINTVL=label name STIMER WAIT,MICVL=label name STIMER WAIT,TUINTVL=label Start a timer and continue. When the time expires the exit routine is invoked. name STIMER REAL,exit,BINTVL=label name STIMER REAL,exit,DINTVL=label name STIMER REAL,exit,MICVL=label name STIMER REAL,exit,TUINTVL=label Only one STIMER can be waiting for expiry at any moment. In each case the label points to a number of timer units. value effect Maximum value BINTVL Fullword with 100th of a second units. X'7FFFFFFF' is approx. 249 days. DINTVL Doubleword PL8'HHMMSSth', where th is 2 decimal positions of seconds. 99595999, approximately 4 days. MICVL Doubleword with microsecond units X'7FFFFFFFFFFFFFFF', or nearly 300000 years TUINTVL Fullword with 26.04166\u00b5s units X'7FFFFFFF', approximately 16 hours. Parameters exit Can be label or (reg). When the time expires, the exit routine is invoked. GR15 has the address of the exit routine. Other registers must be assumed to be destroyed. Note STIMER REAL is measuring clock time, and not the time that the Z390 program is executing. Register Usage R0 = Code for timer units and exit address R1 = Address of the timer units R15 = By implication, exit routine address TTIMER - Test or cancel STIMER REAL Test or cancel a previously set STIMER REAL name TTIMER CANCEL,type,addr Parameters CANCEL CANCEL means that the STIMER timing is terminated. type TU (default) Returns the remaining time in GR0 as 4 bytes in timer units of 26.04166\u00b5s. addr is ignored. MIC,addr Using MIC requires addr which may be specified as label or (reg). The remaining time is returned at the doubleword address in microseconds. Usage Cancel the current STIMER REAL, return the remaining time in GR0 in timer units. TTIMER CANCEL Return the remaining time in microseconds at REMAIN. TTIMER ,MIC,REMAIN ...... REMAIN DS D Register Usage R0 = Code for timer units, returned value R1 = Address of returned timer units Return GR15 has a return code: * 0 TTIMER ok * 4 TU units remaining exceed 31 bits CMDPROC - execute host OS commands Open, close, read and write from the host command processor or shell. With the CMDPROC macro, you can issue OS shell commands, receive the replies from those commands line by line and start other programs. There is a limit of 10 command processors that can be open at any time. The limit is only to protect the operating system from storage depletion. In all cases below, ID may be defined as a numeric value or in a general register. For example, ID=2 or ID=(R5). Parameters ID ID may range from 0 (default) to 9. If the ID exceeds 9 then an abend SFFF will occur Subcommands START name CMDPROC START,ID=,CMDLOG= Start a command processor and assign an identifier. If the memory queue exceeds the MAXQUE value (default 1000) then the memory queue is written to the log and CMDPROC=YES is assumed. An error message is generated. CMDLOG CMDLOG=YES (Default) - All output from the command processor is written to the log. CMDLOG=NO - All output is saved in a memory queue. Use this option if you intend to use CMDPROC READ to retrieve command processor messages. STOP name CMDPROC STOP,ID= Close a previously opened command processor. WRITE name CMDPROC WRITE,label,ID= name CMDPROC WRITE,literal,ID= name CMDPROC WRITE,(reg),ID= Send a command to a previously opened command processor. label or (reg) Points to a constant which terminates with X'00' or is defined as a double-quoted string within a standard C-type constant. literal Double-quoted string within a standard C-type constant preceded by an equals sign. name CMDPROC WRITE,CMD1,ID=5 ...... CMD1 DC C'DIR /X',X'00' name CMDPROC WRITE,CMD1,ID=5 ...... CMD1 DC C'\"DIR /X\"' READ name CMDPROC READ,label,len,ID=,WAIT= Obtain the output, a line at a time, from the result of a command issued by CMDPROC WRITE from a previously opened command processor. label is the receiving area and may be specified as (reg). len Maximum length that is passed to your program. The default is the implied length of the receiving field. Maximum value is 4095 bytes. len may be specified as (reg) . Maximum register value is 2G - 1 bytes. If label is specified as (reg) , then len is mandatory. WAIT= Time in milliseconds before the READ will terminate if no output from the command processor is available to be read. Default is 500 milliseconds. Maximum value is 4095 (4 seconds). WAIT may be specified as (reg). Maximum value is X'7FFFFFFF' (about 24 days). Register Usage R0 = Operation code and ID R1 = Command area R2 = Length R3 = Wait value R15 = Formation of ID and return code Return GR15 has a return code: 0 - CMDPROC ok 4 - READ terminated as WAIT time has expired 8 - READ terminated because the command processor has ended 16 - Command Processor abnormally ended (see log message) WTO - Write to operator Display a message on the GUI console. The record descriptor word (RDW) defines the variable length text message generated by the WTO macro. DC AL2(len,0),C'text' len includes the 4 bytes for the RDW. Formats Text name WTO 'text' The RDW that describes the message is generated internally. List name WTO 'text',MF=L No text is written to the console; only the RDW and text is generated. This allows a 'collection' of messages to be constructed which can be used by the execute form. Execute 1 name WTO MF=E GR1 must be preloaded with the address of an RDW previously generated with the list form of WTO. Execute 2 name WTO MF=(E,label) name WTO MF=(E,(reg)) label or (reg) points to an RDW previously generated with the list form of the WTO. Register Usage R1 = Branch around RDW or parm pointer XLATE - EBCDIC to ASCII name XLATE area,len,TO= Translates data to EBCDIC or ASCII. Parameters area area may be specified as label or (reg) . len len may be specified as a number or (reg). Maximum numeric value is 4095 bytes. Maximum register value is 2G - 1 bytes. TO Type of conversion to perform: TO=A - convert area to ASCII. TO=E - convert area to EBCDIC. Register Usage R0 = Area address and codes R1 = Length WTOR - Write to operator Display a message on the GUI console and receive a response. name WTOR 'text',reply,len,ecb name WTOR \"text\",reply,len,ecb The RDW (see WTO) that describes the message is generated internally. The text appears on the console. Parameters reply Specified as label or (reg), is the field into which the reply is put. The reply appears on the console. len Maximum length of reply. If reply is specified as (reg) then len is mandatory. If len is omitted, then the implied length of reply is used. ecb Specified as label or (reg), by convention defined as DC F'0'. After the WTOR macro, instruction execution can proceed until the reply is completed by the user (commonly the Return key). Usage: Implied length, named ECB, wait for reply immediately. WTOR 'Enter your name',NAME,,MYECB WAIT ECB=MYECB ...... NAME DC CL40' ' MYECB DC F'0' Usage: Register notation, maximum length, no wait for reply. LA R5,NAME LA R6,MYECB WTOR 'Enter your name',(R5),40,(R6) ...... TM MYECB,X'40' BO GOTREPLY ...... NAME DC CL40' ' MYECB DC F'0' Register Usage R0 = Reply address R1 = Branch around RDW R14 = Reply length R15 = ECB address WAIT - Wait for ECB completion name WAIT num,ECB= name WAIT num,ECBLIST= ECB or ECBLIST must be specified. Parameters num num is optional and defaults to 1. For ECB= num must be 1 or omitted. For ECBLIST= num is the minimum number of ECBs that must be posted before the WAIT is complete. This value must, of course, be less or equal to the number of ECBs in the list. An abend SF05 will occur if this is not the case. ECB= Specified as label or (reg). The location of a single 4-byte ECB. ECBLIST= Specified as label or (reg). The location of a sequence of 4-byte addresses, each of which points to a 4-byte ECB. The last 4-byte address must have bit 0 set to 1. Note For DECBs, use the CHECK macro rather than WAIT, otherwise error routines may not be correctly invoked. Usage Wait for 2 out of 3 ECBs. WAIT 2,ECBLIST ...... ECBLIST DC A(ECB1) DC A(ECB2) DC A(X'80000000'+ECB3) ECB1 DC F'0' ECB2 DC F'0' ECB3 DC F'0' Register Usage R0 = Number of ECBs R1 = ECB address POST - Signal ECB completion Signal the completion of one ECB. name POST ecb,code Parameters ecb ecb is required. Specified as label or (reg). The location of a single 4-byte ECB. code code is optional and defaults to zero. Specified as a value (eg. 14 or X'123') or as (reg). Return The completion code is placed in bits 2-31 of the ECB. Register Usage R0 = Event completion code R1 = ECB address CTD - Convert binary or FP value name CTD type,IN=input,OUT=output,LINKAGE= Convert a binary or floating point value to a printable format. Parameters type This is a numeric value which determines the operation to be carried out. Equates are automatically generated. The value of type also determines the length of the input field. type may be specified in a register eg. (R5). Value Equate Length Description 1 CTD_INT128 16 binary 2 CTD_EH 4 short HFP 3 CTD_EB 4 short BFP 4 CTD_DH 8 long HFP 5 CTD_DB 8 long BFP 6 CTD_LH 16 extended HFP 7 CTD_LB 16 extended BFP 8 CTD_DD 8 long DFP 9 CTD_ED 4 short DFP 10 CTD_LD 16 extended DFP IN= The input field may be specified as a literal eg. IN==DH'3.8' , a label, a register pointer eg. IN=(R4) or a register eg. IN=R4 . For some types, input from a register implies the use of a register pair as follows: Value Equate Register specified 1 CTD_INT128 Any even general register, input is from the even/odd pair. 2 CTD_EH Any floating point register. 3 CTD_EB Any floating point register. 4 CTD_DH Any floating point register. 5 CTD_DB Any floating point register. 8 CTD_DD Any floating point register. 9 CTD_ED Any floating point register. 6 CTD_LH The first floating point register of a valid pair, input is from the the register pair. 7 CTD_LB The first floating point register of a valid pair, input is from the the register pair. 10 CTD_LD The first floating point register of a valid pair, input is from the the register pair. OUT= The output field may be specified as a label or a register pointer eg. OUT=(R4) . The output field is always 45 bytes, and is initialized to blanks. Not all 45 bytes may be used. The output field will be ASCII if the ASCII option is used, otherwise EBCDIC will be used. The output field has the following format in this sequence: Output field Condition - If the value is negative n...n Digits preceding the decimal point. If the value is less than 1 and there is no exponent, then 0 is output. eg. 0.04 . Decimal point if there are decimal positions n...n Digits following the decimal point if the value is not a whole number E Indicates an exponent follows - Indicates a negative exponent nnnn The exponent value, 1-4 digits Examples: Value Output zero 0 root2 1.4142... -root2 -1.4142... 50! 3.0414...E64 2 power -50 8.8817...E-16 LINKAGE= SVC (default) invokes SVC 170 CALL generates a CALL to module FPCONMFC Register Usage R0 = Parameter formation R1 = Parameter list R14 = Subroutine call R15 = Subroutine address and return code Return GR15 has a return code: 0 - CTD ok 8 - Invalid data address CFD - Convert to binary or FP value Convert a printable format number to a binary or floating point value. name CFD type,IN=input,OUT=output,LINKAGE= Parameters type This is a numeric value which determines the operation to be carried out. Equates are automatically generated. The value of type also determines the length of the output field. type may be specified in a register eg. (R5). Value Equate Length Description 21 CFD_INT128 16 binary 22 CFD_EH 4 short HFP 23 CFD_EB 4 short BFP 24 CFD_DH 8 long HFP 25 CFD_DB 8 long BFP 26 CFD_LH 16 extended HFP 27 CFD_LB 16 extended BFP 28 CFD_DD 8 long DFP 29 CFD_ED 4 short DFP 30 CFD_LD 16 extended DFP IN= The input field may be specified as a label or a register pointer eg. (R4). The input field must be in ASCII if the ASCII option is used, otherwise EBCDIC. The input field is always 45 bytes, and has the following format in this sequence: output field condition Optional preceding blanks - If the value is negative n...n Digits preceding the decimal point. . Decimal point if there are decimal positions n...n Digits following the decimal point if the value is not a whole number E Indicates an exponent follows - Indicates a negative exponent nnnn The exponent value, 1-4 digits For CFD_INT128, all correct forms are accepted and any decimal places are discarded: 129E-1 = 12 OUT= The output field may be specified as a label, a register pointer eg. OUT=(R4) or a register eg. OUT=R4 For some types, output to a register implies the use of a register pair as follows: Value Equate Register specified 21 CTD_INT128 Any even general register, input is from the even/odd pair. 22 CTD_EH Any floating point register. 23 CTD_EB Any floating point register. 24 CTD_DH Any floating point register. 25 CTD_DB Any floating point register. 28 CTD_DD Any floating point register. 29 CTD_ED Any floating point register. 26 CTD_LH The first floating point register of a valid pair, input is from the the register pair. 27 CTD_LB The first floating point register of a valid pair, input is from the the register pair. 30 CTD_LD The first floating point register of a valid pair, input is from the the register pair. LINKAGE= SVC (default) invokes SVC 171 CALL generates a CALL to module FPCONMFC Register Usage R1 = Parameter list R14 = Subroutine call R15 = Subroutine address and return code Return GR15 has a return code: 0 - CFD ok 8 - Invalid data address 12 - invalid input data or number too large for format type GETENV - Get environment variable Get an environment variable from the OS command environment. GETENV extracts the string in a program. name GETENV setname name GETENV (reg) Parameters setname setname is the label of a null terminated string or the string can be pointed to by reg. SETNAME DC C'MYDATA',X'00' GETENV acquires a storage area for the variable and sets the address in GR2. The string is terminated with X'00'. Register Usage R0 = Function code R1 = setname pointer R2 = Address of variable R15 = Return code Return GR15 has a return code: 0 - GETENV ok 4 - setname is null 8 - variable is null COMRG - Comm region addressability Note VSE only Establish addressability to the Communications region in the ZCVT. COMRG REG=(reg) If REG is omitted it defaults to GR1. It is the users responsibility to provide a DSECT to map the COMRG. Register Usage R1 = Address the ZCVT reg used in REG parm. Supporting Macros COMRG Address Communications region (VSE) Time periods ms - milliseconds 0.001 seconds (one thousandth) \u00b5s - microseconds 0.000001 seconds (one millionth) ns - nanoseconds 0.000000001 seconds (one billionth) Event Control Block Bits 0-1 00 - The initial state. WAIT requires both these bits to be zero. 10 - When the WAIT macro is issued for the ECB, this wait bit is set and the program enters the wait state. 01 - Set to this state internally or by the POST macro indicates that the event is complete or that the task in a wait state is to be resumed. It is valid to test for this state using a bit test instruction like TM. 11 Invalid. Bits 2-31 Completion code, set internally or by the POST macro. SVC functions DEC HEX Service 1 01 WAIT 2 02 POST 11 0B TIME (and date) 11 0B GETIME (VSE) 40 28 GETENV 46 2E TTIMER 47 2F STIMER 52 34 CMDPROC 53 35 WTO 103 67 XLATE 160 A0 WTOR 170 AA CTD 171 AB CFD","title":"SVC services"},{"location":"svc_services/#svc-services","text":"","title":"SVC services"},{"location":"svc_services/#macro-reference","text":"","title":"Macro reference"},{"location":"svc_services/#timesvc-obtain-the-time-and-date","text":"name TIME type,addr,LINKAGE=SVC,DATETYPE=,CLOCKTYPE= Obtain the time and/or date in various formats.","title":"TIME(SVC) - Obtain the time and date"},{"location":"svc_services/#parameters","text":"","title":"Parameters"},{"location":"svc_services/#type","text":"DEC - Decimal name TIME name TIME DEC Returns: Time in GR0 as HHMMSSTH Hours, mins and secs to 2 decimal places. The values are unsigned packed decimal: X'21420654' = 21:42:06.54 The MVO instruction can be used after storing the register to convert it to standard packed decimal format. Date in GR1 as CCYYDDDF - Century, year, day number and sign. The values are signed decimal: CC is (almost) the century number. YY the year number. DDD the day number within the year. F the positive sign. X'0106003F' = 3rd January 2006 After storing, AP DATE,=P'1900000' can be used to convert to a 4-digit year. BIN - Binary name TIME BIN Returns: Time in GR0 in hundredths of a second since midnight in binary. Date in GR1 as CCYYDDDF - Century, year, day number and sign. TU - Time units name TIME TU Returns: Time in GR0 in timer units of 26.04166\u00b5s since midnight in binary. Date in GR1 as CCYYDDDF - Century, year, day number and sign. INS - Instruction count name TIME INS Returns: Instruction count in GR1 (64 bit value). MIC - Microseconds name TIME MIC,label name TIME MIC,(reg) Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified. Date in GR1 as CCYYDDDF - Century, year, day number and sign. NS - Nanoseconds name TIME NS,label name TIME NS,(reg) Returns: Time in units of 1ns in binary since midnight. The time is stored at the 8 bytes specified. STCK - Microseconds bits 0-51 name TIME STCK,label name TIME STCK,(reg) Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. Date in GR1 as above. TS - Timestamp name TIME TS,label name TIME TS,(reg) Returns: A string of 29 bytes at the label or pointed to by reg. The format is \"YYYY-MM-DD HH:MM:SS.NNNNNNNNN\". CLOCK - Microseconds since 1/1/1900 CLOCKTYPE=STCK name TIME CLOCK,label,CLOCKTYPE=STCK name TIME CLOCK,(reg),CLOCKTYPE=STCK Returns: Time in units of 1\u00b5s in binary since 1st January 1900. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. CLOCKTYPE=STCKE name TIME CLOCK,label,CLOCKTYPE=STCKE name TIME CLOCK,(reg),CLOCKTYPE=STCKE Returns: Time in units of 1\u00b5s in binary since 1st January 1900. The time is stored at the 16 bytes specified: Byte 0 : Zero Bytes 1-13 : The time Bytes 14-15 : Programmable field set by the SCKPF instruction and not currently implemented. The time uses only bits 8-111 of the 16-byte field with bits 8-59 being the value in microseconds. CLOCKTYPE=JAVA name TIME CLOCK,label,CLOCKTYPE=JAVA name TIME CLOCK,(reg),CLOCKTYPE=JAVA Returns: Time in units of 1ms in binary since 1st January 1970. The time is stored at the 8 bytes specified.","title":"Type"},{"location":"svc_services/#register-usage","text":"R0 = Code for units and date type R1 = Result area","title":"Register Usage"},{"location":"svc_services/#return","text":"GR15 has a return code: 0 - TIME ok 4 - Invalid request","title":"Return"},{"location":"svc_services/#timesystem-obtain-the-time-and-date","text":"name TIME type,addr,LINKAGE=SYSTEM,DATETYPE=,CLOCKTYPE=","title":"TIME(SYSTEM) - Obtain the time and date"},{"location":"svc_services/#parameters_1","text":"","title":"Parameters"},{"location":"svc_services/#datetype","text":"Specify the date format returned. All the formats are 4 bytes and the values are unsigned packed decimal. The MVO instruction can be used to convert it to standard packed decimal format. YYYY the year number. DDD the day number within the year. DD the day number within the month. MM the month number. YYYYDDD (default) stored as 0YYYYDDD MMDDYYYY DDMMYYYY YYYYMMDD","title":"DATETYPE"},{"location":"svc_services/#type_1","text":"DEC - Decimal name TIME ,label,LINKAGE=SYSTEM name TIME ,(reg),LINKAGE=SYSTEM name TIME DEC,label,LINKAGE=SYSTEM name TIME DEC,(reg),LINKAGE=SYSTEM Returns: Time as HHMMSSTH The time is stored at the 4 bytes specified. Hours, mins and secs to 2 decimal places. The values are unsigned packed decimal: X'21420654' = 21:42:06.54 The MVO instruction can be used to convert it to standard packed decimal format. The date is stored at label+8 or 8(reg). BIN - Binary name TIME BIN,label,LINKAGE=SYSTEM name TIME BIN,(reg),LINKAGE=SYSTEM Returns: The time is stored at the 4 bytes specified in hundredths of a second since midnight The date is stored at label+8 or 8(reg). MIC - Microseconds name TIME MIC,label,LINKAGE=SYSTEM name TIME MIC,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified. The date is stored at label+8 or 8(reg). STCK - Microseconds 0-51 bits only name TIME STCK,label.LINKAGE=SYSTEM name TIME STCK,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. The date is stored at label+8 or 8(reg). STCKE - Microseconds 16 byte name TIME STCKE,label.LINKAGE=SYSTEM name TIME STCKE,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 16 bytes specified: Byte 0 : Zero Bytes 1-13 : The time Bytes 14-15 : Programmable field set by the SCKPF instruction and not currently implemented. The time uses only bits 8-111 of the 16-byte field with bits 8-59 being the value in microseconds. Note The DATETYPE parameter is ignored.","title":"Type"},{"location":"svc_services/#register-usage_1","text":"R0 = Code for units and date type R1 = Result area","title":"Register Usage"},{"location":"svc_services/#return_1","text":"GR15 has a return code: 0 - TIME ok 4 - Invalid request","title":"Return"},{"location":"svc_services/#getime-obtain-time-and-date-vse","text":"GETIME type Obtain the time in various formats (VSE only). The time is stored in the GR0/GR1 register pair.","title":"GETIME - Obtain time and date (VSE)"},{"location":"svc_services/#parameters_2","text":"","title":"Parameters"},{"location":"svc_services/#type-date-type","text":"STANDARD (default) Time in GR1 as 0HHMMSSc . Hours, mins and secs in packed format. BIN - Binary Time in GR1 in seconds since midnight in binary. TU - Time unit Time in GR1 in timer units of 26.04166\u00b5s since midnight in binary. MIC - Microseconds Time in units of 1\u00b5s in binary since midnight.","title":"type - date type"},{"location":"svc_services/#return_2","text":"GR15 has a return code: 0 - GETIME ok 4 - Invalid request","title":"Return"},{"location":"svc_services/#stimer-wait-for-an-interval-of-time","text":"Wait for an interval of time. name STIMER WAIT,BINTVL=label name STIMER WAIT,DINTVL=label name STIMER WAIT,MICVL=label name STIMER WAIT,TUINTVL=label Start a timer and continue. When the time expires the exit routine is invoked. name STIMER REAL,exit,BINTVL=label name STIMER REAL,exit,DINTVL=label name STIMER REAL,exit,MICVL=label name STIMER REAL,exit,TUINTVL=label Only one STIMER can be waiting for expiry at any moment. In each case the label points to a number of timer units. value effect Maximum value BINTVL Fullword with 100th of a second units. X'7FFFFFFF' is approx. 249 days. DINTVL Doubleword PL8'HHMMSSth', where th is 2 decimal positions of seconds. 99595999, approximately 4 days. MICVL Doubleword with microsecond units X'7FFFFFFFFFFFFFFF', or nearly 300000 years TUINTVL Fullword with 26.04166\u00b5s units X'7FFFFFFF', approximately 16 hours.","title":"STIMER - Wait for an interval of time"},{"location":"svc_services/#parameters_3","text":"","title":"Parameters"},{"location":"svc_services/#exit","text":"Can be label or (reg). When the time expires, the exit routine is invoked. GR15 has the address of the exit routine. Other registers must be assumed to be destroyed. Note STIMER REAL is measuring clock time, and not the time that the Z390 program is executing.","title":"exit"},{"location":"svc_services/#register-usage_2","text":"R0 = Code for timer units and exit address R1 = Address of the timer units R15 = By implication, exit routine address","title":"Register Usage"},{"location":"svc_services/#ttimer-test-or-cancel-stimer-real","text":"Test or cancel a previously set STIMER REAL name TTIMER CANCEL,type,addr","title":"TTIMER - Test or cancel STIMER REAL"},{"location":"svc_services/#parameters_4","text":"","title":"Parameters"},{"location":"svc_services/#cancel","text":"CANCEL means that the STIMER timing is terminated.","title":"CANCEL"},{"location":"svc_services/#type_2","text":"TU (default) Returns the remaining time in GR0 as 4 bytes in timer units of 26.04166\u00b5s. addr is ignored. MIC,addr Using MIC requires addr which may be specified as label or (reg). The remaining time is returned at the doubleword address in microseconds.","title":"type"},{"location":"svc_services/#usage","text":"Cancel the current STIMER REAL, return the remaining time in GR0 in timer units. TTIMER CANCEL Return the remaining time in microseconds at REMAIN. TTIMER ,MIC,REMAIN ...... REMAIN DS D","title":"Usage"},{"location":"svc_services/#register-usage_3","text":"R0 = Code for timer units, returned value R1 = Address of returned timer units","title":"Register Usage"},{"location":"svc_services/#return_3","text":"GR15 has a return code: * 0 TTIMER ok * 4 TU units remaining exceed 31 bits","title":"Return"},{"location":"svc_services/#cmdproc-execute-host-os-commands","text":"Open, close, read and write from the host command processor or shell. With the CMDPROC macro, you can issue OS shell commands, receive the replies from those commands line by line and start other programs. There is a limit of 10 command processors that can be open at any time. The limit is only to protect the operating system from storage depletion. In all cases below, ID may be defined as a numeric value or in a general register. For example, ID=2 or ID=(R5).","title":"CMDPROC - execute host OS commands"},{"location":"svc_services/#parameters_5","text":"","title":"Parameters"},{"location":"svc_services/#id","text":"ID may range from 0 (default) to 9. If the ID exceeds 9 then an abend SFFF will occur","title":"ID"},{"location":"svc_services/#subcommands","text":"","title":"Subcommands"},{"location":"svc_services/#start","text":"name CMDPROC START,ID=,CMDLOG= Start a command processor and assign an identifier. If the memory queue exceeds the MAXQUE value (default 1000) then the memory queue is written to the log and CMDPROC=YES is assumed. An error message is generated. CMDLOG CMDLOG=YES (Default) - All output from the command processor is written to the log. CMDLOG=NO - All output is saved in a memory queue. Use this option if you intend to use CMDPROC READ to retrieve command processor messages.","title":"START"},{"location":"svc_services/#stop","text":"name CMDPROC STOP,ID= Close a previously opened command processor.","title":"STOP"},{"location":"svc_services/#write","text":"name CMDPROC WRITE,label,ID= name CMDPROC WRITE,literal,ID= name CMDPROC WRITE,(reg),ID= Send a command to a previously opened command processor. label or (reg) Points to a constant which terminates with X'00' or is defined as a double-quoted string within a standard C-type constant. literal Double-quoted string within a standard C-type constant preceded by an equals sign. name CMDPROC WRITE,CMD1,ID=5 ...... CMD1 DC C'DIR /X',X'00' name CMDPROC WRITE,CMD1,ID=5 ...... CMD1 DC C'\"DIR /X\"'","title":"WRITE"},{"location":"svc_services/#read","text":"name CMDPROC READ,label,len,ID=,WAIT= Obtain the output, a line at a time, from the result of a command issued by CMDPROC WRITE from a previously opened command processor. label is the receiving area and may be specified as (reg). len Maximum length that is passed to your program. The default is the implied length of the receiving field. Maximum value is 4095 bytes. len may be specified as (reg) . Maximum register value is 2G - 1 bytes. If label is specified as (reg) , then len is mandatory. WAIT= Time in milliseconds before the READ will terminate if no output from the command processor is available to be read. Default is 500 milliseconds. Maximum value is 4095 (4 seconds). WAIT may be specified as (reg). Maximum value is X'7FFFFFFF' (about 24 days).","title":"READ"},{"location":"svc_services/#register-usage_4","text":"R0 = Operation code and ID R1 = Command area R2 = Length R3 = Wait value R15 = Formation of ID and return code","title":"Register Usage"},{"location":"svc_services/#return_4","text":"GR15 has a return code: 0 - CMDPROC ok 4 - READ terminated as WAIT time has expired 8 - READ terminated because the command processor has ended 16 - Command Processor abnormally ended (see log message)","title":"Return"},{"location":"svc_services/#wto-write-to-operator","text":"Display a message on the GUI console. The record descriptor word (RDW) defines the variable length text message generated by the WTO macro. DC AL2(len,0),C'text' len includes the 4 bytes for the RDW.","title":"WTO - Write to operator"},{"location":"svc_services/#formats","text":"","title":"Formats"},{"location":"svc_services/#text","text":"name WTO 'text' The RDW that describes the message is generated internally.","title":"Text"},{"location":"svc_services/#list","text":"name WTO 'text',MF=L No text is written to the console; only the RDW and text is generated. This allows a 'collection' of messages to be constructed which can be used by the execute form.","title":"List"},{"location":"svc_services/#execute-1","text":"name WTO MF=E GR1 must be preloaded with the address of an RDW previously generated with the list form of WTO.","title":"Execute 1"},{"location":"svc_services/#execute-2","text":"name WTO MF=(E,label) name WTO MF=(E,(reg)) label or (reg) points to an RDW previously generated with the list form of the WTO.","title":"Execute 2"},{"location":"svc_services/#register-usage_5","text":"R1 = Branch around RDW or parm pointer","title":"Register Usage"},{"location":"svc_services/#xlate-ebcdic-to-ascii","text":"name XLATE area,len,TO= Translates data to EBCDIC or ASCII.","title":"XLATE - EBCDIC to ASCII"},{"location":"svc_services/#parameters_6","text":"","title":"Parameters"},{"location":"svc_services/#area","text":"area may be specified as label or (reg) .","title":"area"},{"location":"svc_services/#len","text":"len may be specified as a number or (reg). Maximum numeric value is 4095 bytes. Maximum register value is 2G - 1 bytes.","title":"len"},{"location":"svc_services/#to","text":"Type of conversion to perform: TO=A - convert area to ASCII. TO=E - convert area to EBCDIC.","title":"TO"},{"location":"svc_services/#register-usage_6","text":"R0 = Area address and codes R1 = Length","title":"Register Usage"},{"location":"svc_services/#wtor-write-to-operator","text":"Display a message on the GUI console and receive a response. name WTOR 'text',reply,len,ecb name WTOR \"text\",reply,len,ecb The RDW (see WTO) that describes the message is generated internally. The text appears on the console.","title":"WTOR - Write to operator"},{"location":"svc_services/#parameters_7","text":"","title":"Parameters"},{"location":"svc_services/#reply","text":"Specified as label or (reg), is the field into which the reply is put. The reply appears on the console.","title":"reply"},{"location":"svc_services/#len_1","text":"Maximum length of reply. If reply is specified as (reg) then len is mandatory. If len is omitted, then the implied length of reply is used.","title":"len"},{"location":"svc_services/#ecb","text":"Specified as label or (reg), by convention defined as DC F'0'. After the WTOR macro, instruction execution can proceed until the reply is completed by the user (commonly the Return key). Usage: Implied length, named ECB, wait for reply immediately. WTOR 'Enter your name',NAME,,MYECB WAIT ECB=MYECB ...... NAME DC CL40' ' MYECB DC F'0' Usage: Register notation, maximum length, no wait for reply. LA R5,NAME LA R6,MYECB WTOR 'Enter your name',(R5),40,(R6) ...... TM MYECB,X'40' BO GOTREPLY ...... NAME DC CL40' ' MYECB DC F'0'","title":"ecb"},{"location":"svc_services/#register-usage_7","text":"R0 = Reply address R1 = Branch around RDW R14 = Reply length R15 = ECB address","title":"Register Usage"},{"location":"svc_services/#wait-wait-for-ecb-completion","text":"name WAIT num,ECB= name WAIT num,ECBLIST= ECB or ECBLIST must be specified.","title":"WAIT - Wait for ECB completion"},{"location":"svc_services/#parameters_8","text":"","title":"Parameters"},{"location":"svc_services/#num","text":"num is optional and defaults to 1. For ECB= num must be 1 or omitted. For ECBLIST= num is the minimum number of ECBs that must be posted before the WAIT is complete. This value must, of course, be less or equal to the number of ECBs in the list. An abend SF05 will occur if this is not the case.","title":"num"},{"location":"svc_services/#ecb_1","text":"Specified as label or (reg). The location of a single 4-byte ECB.","title":"ECB="},{"location":"svc_services/#ecblist","text":"Specified as label or (reg). The location of a sequence of 4-byte addresses, each of which points to a 4-byte ECB. The last 4-byte address must have bit 0 set to 1. Note For DECBs, use the CHECK macro rather than WAIT, otherwise error routines may not be correctly invoked.","title":"ECBLIST="},{"location":"svc_services/#usage_1","text":"Wait for 2 out of 3 ECBs. WAIT 2,ECBLIST ...... ECBLIST DC A(ECB1) DC A(ECB2) DC A(X'80000000'+ECB3) ECB1 DC F'0' ECB2 DC F'0' ECB3 DC F'0'","title":"Usage"},{"location":"svc_services/#register-usage_8","text":"R0 = Number of ECBs R1 = ECB address","title":"Register Usage"},{"location":"svc_services/#post-signal-ecb-completion","text":"Signal the completion of one ECB. name POST ecb,code","title":"POST - Signal ECB completion"},{"location":"svc_services/#parameters_9","text":"","title":"Parameters"},{"location":"svc_services/#ecb_2","text":"ecb is required. Specified as label or (reg). The location of a single 4-byte ECB.","title":"ecb"},{"location":"svc_services/#code","text":"code is optional and defaults to zero. Specified as a value (eg. 14 or X'123') or as (reg).","title":"code"},{"location":"svc_services/#return_5","text":"The completion code is placed in bits 2-31 of the ECB.","title":"Return"},{"location":"svc_services/#register-usage_9","text":"R0 = Event completion code R1 = ECB address","title":"Register Usage"},{"location":"svc_services/#ctd-convert-binary-or-fp-value","text":"name CTD type,IN=input,OUT=output,LINKAGE= Convert a binary or floating point value to a printable format.","title":"CTD - Convert binary or FP value"},{"location":"svc_services/#parameters_10","text":"","title":"Parameters"},{"location":"svc_services/#type_3","text":"This is a numeric value which determines the operation to be carried out. Equates are automatically generated. The value of type also determines the length of the input field. type may be specified in a register eg. (R5). Value Equate Length Description 1 CTD_INT128 16 binary 2 CTD_EH 4 short HFP 3 CTD_EB 4 short BFP 4 CTD_DH 8 long HFP 5 CTD_DB 8 long BFP 6 CTD_LH 16 extended HFP 7 CTD_LB 16 extended BFP 8 CTD_DD 8 long DFP 9 CTD_ED 4 short DFP 10 CTD_LD 16 extended DFP","title":"type"},{"location":"svc_services/#in","text":"The input field may be specified as a literal eg. IN==DH'3.8' , a label, a register pointer eg. IN=(R4) or a register eg. IN=R4 . For some types, input from a register implies the use of a register pair as follows: Value Equate Register specified 1 CTD_INT128 Any even general register, input is from the even/odd pair. 2 CTD_EH Any floating point register. 3 CTD_EB Any floating point register. 4 CTD_DH Any floating point register. 5 CTD_DB Any floating point register. 8 CTD_DD Any floating point register. 9 CTD_ED Any floating point register. 6 CTD_LH The first floating point register of a valid pair, input is from the the register pair. 7 CTD_LB The first floating point register of a valid pair, input is from the the register pair. 10 CTD_LD The first floating point register of a valid pair, input is from the the register pair.","title":"IN="},{"location":"svc_services/#out","text":"The output field may be specified as a label or a register pointer eg. OUT=(R4) . The output field is always 45 bytes, and is initialized to blanks. Not all 45 bytes may be used. The output field will be ASCII if the ASCII option is used, otherwise EBCDIC will be used. The output field has the following format in this sequence: Output field Condition - If the value is negative n...n Digits preceding the decimal point. If the value is less than 1 and there is no exponent, then 0 is output. eg. 0.04 . Decimal point if there are decimal positions n...n Digits following the decimal point if the value is not a whole number E Indicates an exponent follows - Indicates a negative exponent nnnn The exponent value, 1-4 digits Examples: Value Output zero 0 root2 1.4142... -root2 -1.4142... 50! 3.0414...E64 2 power -50 8.8817...E-16","title":"OUT="},{"location":"svc_services/#linkage","text":"SVC (default) invokes SVC 170 CALL generates a CALL to module FPCONMFC","title":"LINKAGE="},{"location":"svc_services/#register-usage_10","text":"R0 = Parameter formation R1 = Parameter list R14 = Subroutine call R15 = Subroutine address and return code","title":"Register Usage"},{"location":"svc_services/#return_6","text":"GR15 has a return code: 0 - CTD ok 8 - Invalid data address","title":"Return"},{"location":"svc_services/#cfd-convert-to-binary-or-fp-value","text":"Convert a printable format number to a binary or floating point value. name CFD type,IN=input,OUT=output,LINKAGE=","title":"CFD - Convert to binary or FP value"},{"location":"svc_services/#parameters_11","text":"","title":"Parameters"},{"location":"svc_services/#type_4","text":"This is a numeric value which determines the operation to be carried out. Equates are automatically generated. The value of type also determines the length of the output field. type may be specified in a register eg. (R5). Value Equate Length Description 21 CFD_INT128 16 binary 22 CFD_EH 4 short HFP 23 CFD_EB 4 short BFP 24 CFD_DH 8 long HFP 25 CFD_DB 8 long BFP 26 CFD_LH 16 extended HFP 27 CFD_LB 16 extended BFP 28 CFD_DD 8 long DFP 29 CFD_ED 4 short DFP 30 CFD_LD 16 extended DFP","title":"type"},{"location":"svc_services/#in_1","text":"The input field may be specified as a label or a register pointer eg. (R4). The input field must be in ASCII if the ASCII option is used, otherwise EBCDIC. The input field is always 45 bytes, and has the following format in this sequence: output field condition Optional preceding blanks - If the value is negative n...n Digits preceding the decimal point. . Decimal point if there are decimal positions n...n Digits following the decimal point if the value is not a whole number E Indicates an exponent follows - Indicates a negative exponent nnnn The exponent value, 1-4 digits For CFD_INT128, all correct forms are accepted and any decimal places are discarded: 129E-1 = 12","title":"IN="},{"location":"svc_services/#out_1","text":"The output field may be specified as a label, a register pointer eg. OUT=(R4) or a register eg. OUT=R4 For some types, output to a register implies the use of a register pair as follows: Value Equate Register specified 21 CTD_INT128 Any even general register, input is from the even/odd pair. 22 CTD_EH Any floating point register. 23 CTD_EB Any floating point register. 24 CTD_DH Any floating point register. 25 CTD_DB Any floating point register. 28 CTD_DD Any floating point register. 29 CTD_ED Any floating point register. 26 CTD_LH The first floating point register of a valid pair, input is from the the register pair. 27 CTD_LB The first floating point register of a valid pair, input is from the the register pair. 30 CTD_LD The first floating point register of a valid pair, input is from the the register pair.","title":"OUT="},{"location":"svc_services/#linkage_1","text":"SVC (default) invokes SVC 171 CALL generates a CALL to module FPCONMFC","title":"LINKAGE="},{"location":"svc_services/#register-usage_11","text":"R1 = Parameter list R14 = Subroutine call R15 = Subroutine address and return code","title":"Register Usage"},{"location":"svc_services/#return_7","text":"GR15 has a return code: 0 - CFD ok 8 - Invalid data address 12 - invalid input data or number too large for format type","title":"Return"},{"location":"svc_services/#getenv-get-environment-variable","text":"Get an environment variable from the OS command environment. GETENV extracts the string in a program. name GETENV setname name GETENV (reg)","title":"GETENV - Get environment variable"},{"location":"svc_services/#parameters_12","text":"","title":"Parameters"},{"location":"svc_services/#setname","text":"setname is the label of a null terminated string or the string can be pointed to by reg. SETNAME DC C'MYDATA',X'00' GETENV acquires a storage area for the variable and sets the address in GR2. The string is terminated with X'00'.","title":"setname"},{"location":"svc_services/#register-usage_12","text":"R0 = Function code R1 = setname pointer R2 = Address of variable R15 = Return code","title":"Register Usage"},{"location":"svc_services/#return_8","text":"GR15 has a return code: 0 - GETENV ok 4 - setname is null 8 - variable is null","title":"Return"},{"location":"svc_services/#comrg-comm-region-addressability","text":"Note VSE only Establish addressability to the Communications region in the ZCVT. COMRG REG=(reg) If REG is omitted it defaults to GR1. It is the users responsibility to provide a DSECT to map the COMRG.","title":"COMRG - Comm region addressability"},{"location":"svc_services/#register-usage_13","text":"R1 = Address the ZCVT reg used in REG parm.","title":"Register Usage"},{"location":"svc_services/#supporting-macros","text":"COMRG Address Communications region (VSE)","title":"Supporting Macros"},{"location":"svc_services/#time-periods","text":"ms - milliseconds 0.001 seconds (one thousandth) \u00b5s - microseconds 0.000001 seconds (one millionth) ns - nanoseconds 0.000000001 seconds (one billionth)","title":"Time periods"},{"location":"svc_services/#event-control-block","text":"","title":"Event Control Block"},{"location":"svc_services/#bits-0-1","text":"00 - The initial state. WAIT requires both these bits to be zero. 10 - When the WAIT macro is issued for the ECB, this wait bit is set and the program enters the wait state. 01 - Set to this state internally or by the POST macro indicates that the event is complete or that the task in a wait state is to be resumed. It is valid to test for this state using a bit test instruction like TM. 11 Invalid.","title":"Bits 0-1"},{"location":"svc_services/#bits-2-31","text":"Completion code, set internally or by the POST macro.","title":"Bits 2-31"},{"location":"svc_services/#svc-functions","text":"DEC HEX Service 1 01 WAIT 2 02 POST 11 0B TIME (and date) 11 0B GETIME (VSE) 40 28 GETENV 46 2E TTIMER 47 2F STIMER 52 34 CMDPROC 53 35 WTO 103 67 XLATE 160 A0 WTOR 170 AA CTD 171 AB CFD","title":"SVC functions"},{"location":"z390_Sort_Utility/","text":"z390 ZSORT The z390 ZSORT internal sort facility is a component of z390 which supports sorting of any number of fixed or variable length records of any size up to the limits of memory and 64 bit file system. ZSORT is implemented with the intent of being compatible with IBM\u00ae DFSORT. SORT utility program SORT.MLC utility assembler program included in the sort and linklib folders performs a sort with the following input files: SORTIN \u2013 unsorted input file with DCB options SORTOUT \u2013 sorted output file with DCB options SYSIN \u2013 sort field definitions SORTWK01/SORTWK02 - sort work files Macro Reference The ZSORT utility function can be called from z390 assembler programs using standard call interface with full work parameters in list pointed to by register 1. The first positional macro parameter contains the operation code and options. The macro operations available: ISORT - initialize for internal sort using PUT to insert unsorted records and GET to retrieve sorted records PUT - insert unsorted record following ISORT GET - return sorted record following last PUT, returns RC=4 at end of sorted records Example usage ZSORT ISORT,LRECL=80,MEMORY=10000000,FIELDS=(1,80,CH,A) ....... ZSORT PUT,REC=(R2) ....... ZSORT GET,REC=(R2) CHI R15,4 BE END_OF_FILE ISORT parameters Note The PUT and GET operations only require the keyword REC= defining address of record area. FIELDS Any number of key fields defined as FIELDS=(offset,length,type,order,{.repeat.}) Offset to start of key starts at 1 and cannot be greater than LRECL. For variable length records the offset does not include the 4 byte prefix. Length of key plus offset must not exceed LRECL Type of sort key field: AC - ASCII characters (same as CH) BI - unsigned binary (same as CH) CH - EBCDIC characters (same as CH) FI - signed binary such as half word, full word, or quad word integers FL - floating point HFP, BFP, or DFP short, long, or extended PD - packed decimal ZD - zoned decimal Order A - Ascending D - Descending LRECL Length of record (may be maximum length of variable length records). MEMORY Amount of memory available for sort table. If no value is specified, the maximum available contiguous memory block within the memory allocated to step by MEM option will be used. Execute format Alternatively the execute form MF=(E,addr) can be used. See linklib\\SORT.MLC for example. Technical details ZSORT is implemented via SVC x'A1' which has 3 function calls: initialize internal sort request submit unsorted record retrieve sorted records. Unsorted records are loaded into a dynamically allocated table in memory and sorted. If the unsorted records exceed the size of the table, then multiple blocks of sorted records are written to a work file and then merged. If all the records fit in the table, then they are sorted and returned without requiring use of sort work files. When required, the merging is performed using two dynamically allocated sort work files with DDNAME's SORTWK01 and SORTWK02. The sorted strings are merged from one work file to another doubling the size of the sorted strings on each pass until all the records are sorted on last merge pass. All file I/O is blocked to minimize disk seeking on single disk systems. User can define the location of SORTWK01 and SORTWK02 if multiple physical disk drives are available. A million records can be sorted in 28 seconds. Statistics on each sort execution are recorded on the statistics file if option STATS is specified.","title":"z390 ZSORT"},{"location":"z390_Sort_Utility/#z390-zsort","text":"The z390 ZSORT internal sort facility is a component of z390 which supports sorting of any number of fixed or variable length records of any size up to the limits of memory and 64 bit file system. ZSORT is implemented with the intent of being compatible with IBM\u00ae DFSORT.","title":"z390 ZSORT"},{"location":"z390_Sort_Utility/#sort-utility-program","text":"SORT.MLC utility assembler program included in the sort and linklib folders performs a sort with the following input files: SORTIN \u2013 unsorted input file with DCB options SORTOUT \u2013 sorted output file with DCB options SYSIN \u2013 sort field definitions SORTWK01/SORTWK02 - sort work files","title":"SORT utility program"},{"location":"z390_Sort_Utility/#macro-reference","text":"The ZSORT utility function can be called from z390 assembler programs using standard call interface with full work parameters in list pointed to by register 1. The first positional macro parameter contains the operation code and options. The macro operations available: ISORT - initialize for internal sort using PUT to insert unsorted records and GET to retrieve sorted records PUT - insert unsorted record following ISORT GET - return sorted record following last PUT, returns RC=4 at end of sorted records","title":"Macro Reference"},{"location":"z390_Sort_Utility/#example-usage","text":"ZSORT ISORT,LRECL=80,MEMORY=10000000,FIELDS=(1,80,CH,A) ....... ZSORT PUT,REC=(R2) ....... ZSORT GET,REC=(R2) CHI R15,4 BE END_OF_FILE","title":"Example usage"},{"location":"z390_Sort_Utility/#isort-parameters","text":"Note The PUT and GET operations only require the keyword REC= defining address of record area.","title":"ISORT parameters"},{"location":"z390_Sort_Utility/#fields","text":"Any number of key fields defined as FIELDS=(offset,length,type,order,{.repeat.}) Offset to start of key starts at 1 and cannot be greater than LRECL. For variable length records the offset does not include the 4 byte prefix. Length of key plus offset must not exceed LRECL Type of sort key field: AC - ASCII characters (same as CH) BI - unsigned binary (same as CH) CH - EBCDIC characters (same as CH) FI - signed binary such as half word, full word, or quad word integers FL - floating point HFP, BFP, or DFP short, long, or extended PD - packed decimal ZD - zoned decimal Order A - Ascending D - Descending","title":"FIELDS"},{"location":"z390_Sort_Utility/#lrecl","text":"Length of record (may be maximum length of variable length records).","title":"LRECL"},{"location":"z390_Sort_Utility/#memory","text":"Amount of memory available for sort table. If no value is specified, the maximum available contiguous memory block within the memory allocated to step by MEM option will be used.","title":"MEMORY"},{"location":"z390_Sort_Utility/#execute-format","text":"Alternatively the execute form MF=(E,addr) can be used. See linklib\\SORT.MLC for example.","title":"Execute format"},{"location":"z390_Sort_Utility/#technical-details","text":"ZSORT is implemented via SVC x'A1' which has 3 function calls: initialize internal sort request submit unsorted record retrieve sorted records. Unsorted records are loaded into a dynamically allocated table in memory and sorted. If the unsorted records exceed the size of the table, then multiple blocks of sorted records are written to a work file and then merged. If all the records fit in the table, then they are sorted and returned without requiring use of sort work files. When required, the merging is performed using two dynamically allocated sort work files with DDNAME's SORTWK01 and SORTWK02. The sorted strings are merged from one work file to another doubling the size of the sorted strings on each pass until all the records are sorted on last merge pass. All file I/O is blocked to minimize disk seeking on single disk systems. User can define the location of SORTWK01 and SORTWK02 if multiple physical disk drives are available. A million records can be sorted in 28 seconds. Statistics on each sort execution are recorded on the statistics file if option STATS is specified.","title":"Technical details"},{"location":"Options/z390_filetypes/","text":"z390 File types The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module File extension Scope Format File Description File or Report Format Description BAL MA ASCII Basic Assembly Language generated ASCII source file generated by mz390 when option BAL is specified. When option ASM is on (the default), mz390 starts az390 as a separate process running in parallel and passes generated BAL statements directly to it. This allows the first pass of assembler processing to be overlapped with macro expansion and eliminates need to write this file to external disk. Basic Assembler format is free form within first 71 characters with optional label starting in position 1 followed by opcode followed by operands if any. If continuation is required a non-space character appears in position 72. Positions 73-80 may be used for sequence numbering. The ICTL instruction may be used to change these default settings but it is not recommended as the macro and copybook files are all in the default format. Embedded AREAD records longer than 71 characters must be in standard continuation format for preloading of MLC and MAC files (a z390 restriction). Note the default NOALLOW limits AREAD and PUNCH records to maximum of 80. CPY MA ASCII Copybook source included in source programs, macros, or other copybooks. Same format as BAL. DAT M ASCII Text data input files read via AREAD statements in macro processor specifying ID=, DDNAME= or DSNAME= extended parameters. AREAD with no extended parameters reads the next statement in the input stream. Same format as BAL except text records can be any length with no continuation format required using ALLOW. ERR MALE ASCII Output log of all START and ENDED messages plus any errors plus any error file references. Text file with messages showing start and stop statistics for each step and any error messages issued by those steps. A cross reference of all macro and copybook files with errors is included at the end. For full cross reference of all macros and copybooks used see STA file. LOG E ASCII Output log for GUI or batch command execution controlled by CON option. Test file with messages issued during program execution including start and stop statistics plus any errors and any WTO write to operator messages. LKD L ASCII Optional input command for linker (INCLUDE, ENTRY, ALIAS, NAME). Same format as BAL. MAC M ASCII Macro source files Same format as BAL. MLC M ASCII Macro assembler source programs read by mz390. Same format as BAL. MOD LE Binary Binary code output from linker with no header and no RLD records. This type file can be created using option MOD and can be loaded as a data table by Micro Focus CICS. Binary file with all CSECT binary data. For example DC C'ABC' using option MOD will result in 3 byte MOD file containing x'C1C2C3'. OBJ AL EBCDIC, ASCII Output relocatable object code file for macro assembler with two format options. The default is mainframe linker compatible relocatable object code 80 byte records (ESD, TXT, RLD, and END). When OBJHEX option is specified for assembler, ASCII readable text extended format supporting 31 bit long sections is generated. The z390 linker can read either format by examining the file. OPT MALE ASCII Optional options files referenced via @file option from command line or other option files Text file with z390 options entered in free format delimited by spaces. An * will terminate options on a line and start comments on that line. PCH M ASCII Output text files written via PUNCH statements in macro processor using optional ID=, DDNAME=, or DSNAME= extended parameters. The default is pgm.PCH. Text file output which is not limited to 80 byte BAL format using ALLOW. Any macro program generating BAL output must format continuations. PRN A ASCII Output assembly language listing from az390. Text file with the following listing fields: 1) hex relative offset to instruction 2) hex bytes in instruction or data with up to 8 bytes per line. Direction PRINT DATA will force listing all data 8 bytes per line. 3) (file #/file-line #) generated-line # identified the file # and the relative file line # for the MLC, MAC, or CPY file that the generated line came from followed by the sequential generated line #. 4) Flag field has + for macro generated lines, and = for line from copybook. 5) BAL line with label, opcode, and operands. STA MALE ASCII Output statistics file listing options set, program statistics, and file references. Text file with detail statistics on each step including all option settings, complete macro and copybook cross reference for mz390, and execution statistics. TRA A ASCII Trace output file for assembler (lists each line being assembled during each pass). Text file with az390 assembler trace output including source file name, relative line, generated line, relative hex offset, and source statement for each assembler pass which may be 2 or more depending on usage of LOCTR. TRE E ASCII Trace output file for emulator (lists each instruction, address, and operand values). Text file with ez390 emulator execution trace output showing, hex PSW address, condition code, hex instruction, mnemonic, operand register and storage values at the start of each instruction. Blank line inserted for each branch to non sequential address. The high bit of PSW hex address indicates 24 or 31 bit address mode. TRL L ASCII Trace output file for linker (lists each OBJ record processed). Text file with lz390 linker trace output including ESD external symbol hex addresses and lengths, TXT text records with relative offset within ESD and hex data. RLD relocation records showing hex offset, field length, and ESD symbol. TRM M ASCII Trace output file for macro process (TRACEM lists each macro line executed, TRACEP lists every macro pseudo code instruction executed showing the current value of local and global variables used in SET statements and AIF statements etc). Text file with mz390 macro processor trace output file which is typically generated in parallel with the generation of the first pass information in the TRA file since mz390 and az390 run as concurrent tasks. This file includes source file name, relative line number, and source macro statement. For generated BAL output lines the source file# and relative line# cross reference is also include. If the TRACEP option is specified, this file also includes listing of the generation and execution of macro pseudo code instructions. TRS E ASCII Report from ZPARTRS utility Trace CBL AND ASM source execution. ZSM M ASCII ZSTRMAC Structured Conditional Macro source programs. Use ZSTRMAC.BAT file1 file2 to translate ZSM type file to standard HLASM compatible MLC type source file. 390 LE Binary Executable z390 load modules created by linker from OBJ files and loaded by emulator. The 390 load modules contain 20 byte header with the following: 1) 4 byte ASCII character version '1002' 2) 1 byte flag AMODE31 'T' or 'F' 3) 1 byte flag RMODE31 'T' or 'F' 4) 2 bytes reserved '??' 5) 4 byte length of code 6) 4 byte offset to entry 7) 4 byte count of RLD's following code The code for all CSECT's follows the header. The RLD table follows the code if any. Each RLD field in load module is relocated by the load address determined at load time. The 5 byte RLD records are as follows: 1) 4 byte offset to RLD field in code 2) 1 byte field length See option MOD and file type MOD to create code without header or any RLD's.","title":"z390 File types"},{"location":"Options/z390_filetypes/#z390-file-types","text":"The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module File extension Scope Format File Description File or Report Format Description BAL MA ASCII Basic Assembly Language generated ASCII source file generated by mz390 when option BAL is specified. When option ASM is on (the default), mz390 starts az390 as a separate process running in parallel and passes generated BAL statements directly to it. This allows the first pass of assembler processing to be overlapped with macro expansion and eliminates need to write this file to external disk. Basic Assembler format is free form within first 71 characters with optional label starting in position 1 followed by opcode followed by operands if any. If continuation is required a non-space character appears in position 72. Positions 73-80 may be used for sequence numbering. The ICTL instruction may be used to change these default settings but it is not recommended as the macro and copybook files are all in the default format. Embedded AREAD records longer than 71 characters must be in standard continuation format for preloading of MLC and MAC files (a z390 restriction). Note the default NOALLOW limits AREAD and PUNCH records to maximum of 80. CPY MA ASCII Copybook source included in source programs, macros, or other copybooks. Same format as BAL. DAT M ASCII Text data input files read via AREAD statements in macro processor specifying ID=, DDNAME= or DSNAME= extended parameters. AREAD with no extended parameters reads the next statement in the input stream. Same format as BAL except text records can be any length with no continuation format required using ALLOW. ERR MALE ASCII Output log of all START and ENDED messages plus any errors plus any error file references. Text file with messages showing start and stop statistics for each step and any error messages issued by those steps. A cross reference of all macro and copybook files with errors is included at the end. For full cross reference of all macros and copybooks used see STA file. LOG E ASCII Output log for GUI or batch command execution controlled by CON option. Test file with messages issued during program execution including start and stop statistics plus any errors and any WTO write to operator messages. LKD L ASCII Optional input command for linker (INCLUDE, ENTRY, ALIAS, NAME). Same format as BAL. MAC M ASCII Macro source files Same format as BAL. MLC M ASCII Macro assembler source programs read by mz390. Same format as BAL. MOD LE Binary Binary code output from linker with no header and no RLD records. This type file can be created using option MOD and can be loaded as a data table by Micro Focus CICS. Binary file with all CSECT binary data. For example DC C'ABC' using option MOD will result in 3 byte MOD file containing x'C1C2C3'. OBJ AL EBCDIC, ASCII Output relocatable object code file for macro assembler with two format options. The default is mainframe linker compatible relocatable object code 80 byte records (ESD, TXT, RLD, and END). When OBJHEX option is specified for assembler, ASCII readable text extended format supporting 31 bit long sections is generated. The z390 linker can read either format by examining the file. OPT MALE ASCII Optional options files referenced via @file option from command line or other option files Text file with z390 options entered in free format delimited by spaces. An * will terminate options on a line and start comments on that line. PCH M ASCII Output text files written via PUNCH statements in macro processor using optional ID=, DDNAME=, or DSNAME= extended parameters. The default is pgm.PCH. Text file output which is not limited to 80 byte BAL format using ALLOW. Any macro program generating BAL output must format continuations. PRN A ASCII Output assembly language listing from az390. Text file with the following listing fields: 1) hex relative offset to instruction 2) hex bytes in instruction or data with up to 8 bytes per line. Direction PRINT DATA will force listing all data 8 bytes per line. 3) (file #/file-line #) generated-line # identified the file # and the relative file line # for the MLC, MAC, or CPY file that the generated line came from followed by the sequential generated line #. 4) Flag field has + for macro generated lines, and = for line from copybook. 5) BAL line with label, opcode, and operands. STA MALE ASCII Output statistics file listing options set, program statistics, and file references. Text file with detail statistics on each step including all option settings, complete macro and copybook cross reference for mz390, and execution statistics. TRA A ASCII Trace output file for assembler (lists each line being assembled during each pass). Text file with az390 assembler trace output including source file name, relative line, generated line, relative hex offset, and source statement for each assembler pass which may be 2 or more depending on usage of LOCTR. TRE E ASCII Trace output file for emulator (lists each instruction, address, and operand values). Text file with ez390 emulator execution trace output showing, hex PSW address, condition code, hex instruction, mnemonic, operand register and storage values at the start of each instruction. Blank line inserted for each branch to non sequential address. The high bit of PSW hex address indicates 24 or 31 bit address mode. TRL L ASCII Trace output file for linker (lists each OBJ record processed). Text file with lz390 linker trace output including ESD external symbol hex addresses and lengths, TXT text records with relative offset within ESD and hex data. RLD relocation records showing hex offset, field length, and ESD symbol. TRM M ASCII Trace output file for macro process (TRACEM lists each macro line executed, TRACEP lists every macro pseudo code instruction executed showing the current value of local and global variables used in SET statements and AIF statements etc). Text file with mz390 macro processor trace output file which is typically generated in parallel with the generation of the first pass information in the TRA file since mz390 and az390 run as concurrent tasks. This file includes source file name, relative line number, and source macro statement. For generated BAL output lines the source file# and relative line# cross reference is also include. If the TRACEP option is specified, this file also includes listing of the generation and execution of macro pseudo code instructions. TRS E ASCII Report from ZPARTRS utility Trace CBL AND ASM source execution. ZSM M ASCII ZSTRMAC Structured Conditional Macro source programs. Use ZSTRMAC.BAT file1 file2 to translate ZSM type file to standard HLASM compatible MLC type source file. 390 LE Binary Executable z390 load modules created by linker from OBJ files and loaded by emulator. The 390 load modules contain 20 byte header with the following: 1) 4 byte ASCII character version '1002' 2) 1 byte flag AMODE31 'T' or 'F' 3) 1 byte flag RMODE31 'T' or 'F' 4) 2 bytes reserved '??' 5) 4 byte length of code 6) 4 byte offset to entry 7) 4 byte count of RLD's following code The code for all CSECT's follows the header. The RLD table follows the code if any. Each RLD field in load module is relocated by the load address determined at load time. The 5 byte RLD records are as follows: 1) 4 byte offset to RLD field in code 2) 1 byte field length See option MOD and file type MOD to create code without header or any RLD's.","title":"z390 File types"},{"location":"Options/z390_options/","text":"z390 Options The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the SYSMAC parameter is quoted as it uses parentheses, whereas the ALIGN parameter is not. \"SYSMAC(foldername)\" ALIGN Option Scope Default Description @filename MALE Options in Z390.OPT file if found. Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. If a file named Z390.OPT exists in the z390 install directory, these options will be applied first as default options. ALIGN A YES Align DS/DC data fields based on type unless explicit length is specified. If duplication factor is 0, then NOALIGN is ignored. ALLOW M NO Allow extensions to HLASM syntax including: 1) No quotes required for SETC variables. 2) Duplication factor does not require (..). 3) Array declarations with variables in expression accepted 4) Substring starting beyond end returns null string 5) Quoted strings allowed in SETA and SETB expressions 6) Allow &var as null string if not found during substitution 7) Allow duplicate local and global variable declarations 8) Allow AREAD and PUNCH file records greater than 80 characters. The default of NOALLOW insures HLASM compatibility. AMODE24 LE NO Set 390 load module options to start in 24 bit address mode. AMODE31 LE YES Set 390 load module options to start in 31 bit address mode. ASCII AE NO Generate ASCII versus EBCDIC DC character constants, compare character strings in ASCII versus EBCDIC in macro processor, generate ASCII versus EBCDIC output for UNPK, ED, and EDMK. Note ASCII mode is not mainframe compatible and requires careful review of program to insure no EBCDIC immediate compare constants such as X'40', 64, X'F0', 240 etc. are used and that there are no assumptions about EBCDIC versus ASCII collating sequences which have numbers and letters reversed, and EBCDIC letters are non-contiguous. Typically HLASM compatible programs are run in default EBCDIC mode and DCB RECFM=FT|VT or some other translation option is used to convert between EBCDIC and ASCII where necessary. Note there are a few instructions affected by ASCII mode: 1) ED/EDMK generate ASCII versus EBCDIC but the mask must always be in EBCDIC (masks are usually coded in X'...' format) 2) UNPK generates X'3' versus X'F' in zone field (high order nibble). ASM MA YES Run az390 assembler as subtask of mz390 passing BAL. Note NOASM is for use in pure text processing programs which only use conditional macro code and AREAD/PUNCH with extensions to process ASCII text files. NOASM does not support ordinary symbol attribute tests, OPSYN, or lookahead mode, and requires CHKMAC(0) and CHKSRC(0-2). ASSIST MAE NO Enable assembly and execution of ASSIST I/O and debugging instructions. This option also sets NOLOADHIGH. See ASSIST Support . AUTOLINK L YES Search for unresolved external references in SYSOBJ directory list which defaults to linklib. BAL M NO Generate BAL expanded assembler source file. BS2000 MA NO Support Siemens BS2000 assembler global variables. CHKMAC(0-2) M 0 Check macros during loading as follows: 0 - no checking 1- check for missing AGO and AIF labels and issue warning 2 - also check missing labels and also check for non comment text after MEND. CHKSRC(0-3) MA 1 Check input source files as follows: 0 - no checking 1 - check MLC or BAL input source files for any non-ASCII characters and issue error 2 - check MLC, MAC, CPY, and BAL input source files for any non-ASCII characters and issue error. 3 - also check for out of sequence characters in 73-80 or any non-blank characters beyond 80 and issue error. Note this should detect any EBCDIC literal character strings containing non-ASCII characters such as binary 0 byte which must be changed to hex X'00' type strings for portability. CICS MA NO Support EXEC CICS pre-processor expansion and constants. If this option is not on during macro expansion, PROLOG and EPILOG option settings will be ignored. CODEPAGE(ascii+ebcdic+LIST) MALE YES The default is CODEPAGE(ISO-8859-1+IBM1047). If +LIST is added the mapping of the 2 codepages along with printable character and Unicode values are displayed on ERR file. A hex dump of the tables and a list of the valid ASCII and EBCDIC Unicode Charset codepages are listed. You can replace the EBCDIC codepage name with a file specification such as IBM1047.HCP (example included) which is in hex dump format. The above defaults match z/OS. CON MALE YES Console output for all start/stop, error, trace, MNOTE's with level > 4, and WTO messages. When the TRACE??? option is specified, the CON option is turned off so only start/stop and abort error messages appear on console log. You can specify CON after last TRACE option to turn it back on if you want all display, trace, and error messages displayed on console log. All the trace messages appear on corresponding TR? file for each z390 program executed. DUMP E NO Generate full memory dump on LOG or TRE if abort. EDF M YES CICS Execution Diagnostic Facility. EPILOG M YES Generate epilog macro call DFHEIEND for CICS program at END statement if CICS option and EPILOG option are on. ERR(100) MALE 100 Terminate process if total errors for program exceeds limit. Use ERR(0) to eliminate any error limit and always generate PRN file. ERRSUM M NO Generate critical error summary on console and ERR file listing missing macros and copybooks. This option requires ASM option and is turned on automatically if missing macros or copybooks are found in the executed macro code path. When ERRSUM is on, ERR(0) is set to prevent abort prior to finding all macro and copybook references. All errors are listed on ERR file along with summary report. Note several iterations may be required to identify and resolve all missing macros and copybooks. GUAM E NO Support one or more GUI Graphical User Access Method dialogs for MCS, TN3270, or graphics user interface. INIT E YES Initialize all registers to hex x'F4', all memory to hex x'F5', and all uninitialized load module areas to x'F6' for easier identification of access to uninitialized registers, memory or program fields. Use NOINIT to perform low value initialization. INSTALL(dir) MALE NO Define alternate z390 install directory to run batch command. The default is set from Java property \"user.dir\". IPL(pgm) E none Execute 390 program at startup. LIST ALE YES Generate PRN, LST, and LOG files for assembler, linker, and execution respectively. LISTCALL MA YES Generate level macro call and exit comments in BAL file which are used by assembler to format first level macro calls preceding assembler lines with \"+\" for macro generated source. LISTUSE A YES List active USING definitions each time USING or DROP changes status in the PRN assembly listing file. LOADHIGH E YES Load programs and allocate memory for GETMAIN/STORAGE from high end of first FQE large enough to satisfy request. The ASSIST option changes this option to NOLOADHIGH causing initial program to load starting at X'8000' which simplifies relative address calculations. LOG(file) MALE pgm Set file name for ERR, TR?, and LOG files. The default is the program name. This option is required when running multiple copies of the same program via CMD startup in order to create separate unique ERR, TR?, and LOG files. Otherwise duplicate programs running in parallel will mod the same ERR, TR?, and LOG file. MAXCALL(50) M 50 Set limit for nested macro calls. MAXDISPLAY(80) M 80 Use to increase zCOBOL DISPLAY line size up to 256 characters. MAXESD(1000) AL 1000 Set limit for ESD sections or entries in one program. MAXFILE(1000) M 1000 Maximum macro and copybook files. MAXGBL(1000000) M 100000 Maximum global macro variables. MAXHEIGHT(600) E 600 Maximum pixel height for GUI dialog windows. MAXLCL(100000) M 100000 Maximum local macro variables. MAXLINE(200000) MA 200000 Maximum MLC, MAC, CPY, and BAL source lines that can be loaded into memory during an assembly. MAXLOG(1000000) MALE 1000000 Maximum GUI log file output before truncation begins by removing 50% to limit memory consumption. The only limit on size of log file is MAXSIZE. MAXPARM(100000) M 10000 Maximum length of any string during macro processing. This is an extension as HLASM limit is currently 1024. MAXPASS(2) A 2 Maximum passes of the BAL source by assembler to resolve forward nested symbol references prior to final pass to generate object code. The number of LOCTR statements is added to this limit in order to resolve the final address of each LOCTR section. MAXPC(50000) M 50000 Maximum pseudo code instructions held in cache before LRU replacement begins. MAXQUE(1000) E 1000 Maximum output queue length from any CMD started task before queue messages are automatically copied to GUI output log to conserve memory and prevent stall. MAXRLD(10000) L 10000 Maximum RLD relocation records allowed in a program. MAXSIZE(50) MALE 50 Maximum size of any output file in MB. MAXSYM(50000) MA 50000 Maximum symbols in one macro assembly. MAXWARN(4) MA 4 Maximum MNOTE warning level without generating error. MAXWIDTH(800) E 800 Maximum pixel width for GUI dialog windows. MCALL A NO List each macro call and exit on the PRN assembly listing in addition to first level calls if LISTCALL option is also on. MEM(1) E 1 Memory allocated for 390 program execution in MB. Note for RMODE31 loads and GETMAIN's memory above the 16 MB line must be allocated. For example MEM(32) would provide 16 MB below the line and 16 MB above. MINHEIGHT(150) E 150 Minimum pixel height for GUI dialog windows. MINWIDTH(150) E 150 Minimum pixel width for GUI dialog windows. MNOTE(0) MA 0 Control MNOTE error/warning messages during macro expansion and assembly: 0 - default generates MNOTE error/warning during mz390 and az390 1 - suppress mz390 error/warning and only pass MNOTE to az390 2 - generates MNOTE error/warning during mz390 and suppresses passing them on to az390. MOD L NO Generate raw code file from lz390 with .MOD suffix and no header or trailer and no RLD's. OBJ A YES Generate relocatable object code file. OBJHEX A NO Generate ASCII readable form of OBJ file with support for 31 bit long sections. The default is to generate binary OBJ file which is compatible with mainframe linkers but is limited to 24 bit long sections. PARM('text') E none Define character string parm passed to executable program via address in R1 at startup pointing to a fullword pointing to a halfword length followed by EBCDIC characters. When the length is zero, no PARM is present. PC M YES Generate macro pseudo code in cache memory for speeding up macro code that is executed more than once during macro expansion. PCOPT M YES Optimize macro pseudo code by looking for push, add/sub, store sequences and replacing them with inc/dec pseudo code opcodes. These pseudo codes are maintained in a cache in memory during macro execution only and have no effect on generated object code. PRINTALL A NO Suppress PRINT OFF and PRINT NOGEN commands to force all source lines on PRN listing. PDSMEM8 M NO If PDSMEM8 option is specified, error messages will be issued for any macro or copybook file names with length greater than 8. This option is available to provide compatibility with mainframe PDS libraries that are limited to 8 character names. Note zCOBOL and zCICS use names longer than 8 characters such as zcobol\\IDENTIFICATION.MAC and cics\\CICS_INQUIRE.MAC. PROFILE(file) M NO Insert COPY file in front of MLC source file. PROLOG M YES Generate CICS prolog macro calls DFHEIGBL, DFHEISTG, and DFHEIENT if CICS option and PROLOG options are on. PROTECT E YES Prevent modification of PSA in low memory 8K block. REFORMAT M NO Reformat expanded BAL code to align all opcodes at column 10 and operands at column 16 if possible. REGS E NO Generate GPR register trace before and after each instruction if TRACE option on. RMODE24 LE YES Set 390 load module options to load module below the 24 bit address line. RMODE31 LE NO Set 390 load module options to load module above the 31 bit address line. Note this load module option requires option MEM be set to include enough memory above the 31 bit address line. STATS or STATS(file) MALE NO Generate statistics file STA with final options listing, macro and copybook file listing, plus all program statistics. If file is omitted the program path and file name are used with STA suffix. SYS390(dir) LE pgm dir Define directory for storing and retrieving 390 load modules. SYSBAL(dir) MA pgm dir Define directory for storing and retrieving generated BAL files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSCPY(dir) MA pgm dir Define one or more directories for retrieving CPY source input files. If the option starts with + the directories listed will be concatenated with current list. Multiple directories are always separated by +. This option may also override suffix by adding *.sfx. SYSDAT(dir) M pgm dir Define directory for retrieving DAT source input files for AREAD. Set to SYSDAT(.) for current directory when no path is specified on DSNAME parm for AREAD. SYSERR(dir) MALE pgm dir Define directory for output ERR files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLKD(file) L pgm dir Define input source file for linker commands such as INCLUDE, ALIAS, ENTRY, and NAME. SYSLOG(dir) E pgm dir Define directory for output LOG file. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLST(dir) AL pgm dir Define directory for output LST files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSMAC(dir) M mac dir Define one or more directories for source MAC files. If the option starts with + the directories listed will be appended to the maclib list. Multiple directories can be specified in one parameter and are always separated by +. When you specify this option more than once and want previous parameter instructions to remain in place, ensure that you start parameter with a + otherwise it will drop prior directories. This option may also override suffix by adding *.sfx. SYSMLC(dir) MA pgm dir Define directory for source input MLC files. SYSOBJ(dir) AL pgm dir Define directory for OBJ relocatable object files. SYSOPT(dir) MALE pgm dir Define directory for @file option files. This option may override suffix using *.sfx. SYSPARM('text') M none Define text string which can be accessed by mz390 global macro variable &SYSPARM. SYSPCH(dir) M pgm dir Define directory for PCH output files from PUNCH. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). Note PUNCH output is in ASCII source format and is not directed to the OBJ file. These files may be used as linker input commands via SYSLKD(file) option. Set to SYSPCH(.) for current directory when no path is specified on DSNAME parm for PUNCH. SYSPRN(dir) A pgm dir Define directory for assembler listing PRN output files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSTERM(file) MALE pgm.ERR Define alternate file for all start/end messages plus any error messages, plus related source file statistics for each file containing errors. The default is the program name with ERR suffix. SYSTRC(dir) MALE pgm dir Define directory for output TRACE TR? files. TEST E NO Start execution with interactive TEST mode active which prompts for commands such as T opcode or G opcode to trace or execution to the next occurrence of opcode name. TEST(ddname) E NO Define input command file to run TEST commands. ddname is an environment variable set to the name of the command file. THREAD A NO Assign continuing CSECT addresses for multiple CSECT's assembled in the same module to help identify location of instruction and data labels. TIME or TIME(seconds) MALE YES Limit execution time of each program to the number of seconds specified. The default is 15 seconds. This option is turned off if NOTIMING specified. Use NOTIME to allow tasks such as SOA servers like z390CICS to run continuously while still supporting application use of timing functions. TIMING MALE YES Calculate elapsed time and instructions per second statistics for display on START/END messages and STA statistics. TIMING also displays current z390 and J2SE version on start message and memory usage on ended message. Note NOTIMING is used in regression tests to force generated files to be identical by using fixed data/time stamp using GregorianCalendar(2005,0,2,22,33,44). NOTIMING suppresses versions on start message and memory usage on ended message. NOTIMING also sets NOTIME which prevents application from using time functions. TRACE or TRACE(AEGILMPQTV) E NO Turn on ez390 execution trace generation on TRE file and turn off CON. TRACE will display every instruction executed along with address and value of each operand. Any combination of the following trace options can be set using the TRACE(...) option. TRACE(*) will also set TRACEALL. Note the &SYSTRACE global SETC variable can be used to turn any trace options on or off during execution. TRACEA or TRACE(A) A NO Turn on az390 assembly trace generation on TRA file and turn off CON. TRACEA will display each BAL statement during each pass of the assembler. TRACEALL MALE NO Turn on all trace options generating TRM, TRA, TRL, and TRE files and turn off CON. TRACEC or TRACE(C) M NO Trace copy file code for TRACEM and TRACEP. The default is NOTRACEC to eliminate redundant code that usually just contains global variable declarations. TRACEG or TRACE(G) E NO Turn on ez390 emulator trace generation on TRE file with trace of GETMAIN/FREEMAIN FQE memory management control block changes and turn off CON. TRACEI or TRACE(I) M NO TRACEI will trace each AINSERT showing source on the TRM trace file. TRACEL or TRACE(L) L NO Turn on lz390 linker trace generation on TRL file and turn off CON. TRACEL shows each CSECT, ENTRY, EXTRN and OBJ file being loaded. TRACEM or TRACE(M) M NO Turn on mz390 macro processor trace generation on TRM file and turn off CON. TRACEM displays each conditional macro statement executed plus stored values and AIF compare values. TRACEP or TRACE(P) M NO Turn on mz390 macro processor pseudo code generation and execution trace on TRM file and turn off CON. TRACEP shows each conditional macro pseudo operation performed for each conditional macro statement and the values of all variables. TRACEQ or TRACE(Q) E NO Turn on ez390 emulator QSAM/BSAM DCB I/O trace generation on TRE file and turn off CON. TRACES or TRACE(S) M NO Display MLC source lines on console regardless of CON setting to help locate any loops, waits, or hangs in large macro process. If MCALL is also on, then *MCALL and *MEXIT comments will also be displayed to show location with nested macros. TRACET or TRACE(T) E NO Turn on ez390 emulator TGET/TPUT and TCP/IO trace generation on TRE file and turn off CON. TRACEV or TRACE(V) E NO Turn on ez390 emulator VSAM ACB/RPL I/O trace generation on TRE file and turn off CON. TRAP E YES Trap any unexpected J2SE program exceptions and generate emulator 0C5 exception which can be handled by SPIE/STAE exits if defined. NOTRAP can be used with Eclipse source debugger to stop at J2SE statement causing exception. TS MALE NO Generate JDBC compatible time-stamp on all TRACE and ERR file records for use in debugging time dependent issue. VCB E YES Generate VSAM cache buffer for improving VSAM performance by storing most recently accessed records and indexes. XREF A YES Cross reference symbols to source lines in PRN assembly listing. ZSTRMAC M YES Support expansion of ZSTRMAC structured conditional macro code instructions during loading of MLC, MAC, and CPY files. Note z390 macros in z390\\mac directory now are using zstrmac for structured coding. NOZSTRMAC can only be used with MVS, VSE, or other non-structured macro libraries. ZVSAM E 0 ZVSAM 0=no vsam, 1=zvsam1 support, 2=zvsam2 support.","title":"z390 Options"},{"location":"Options/z390_options/#z390-options","text":"The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the SYSMAC parameter is quoted as it uses parentheses, whereas the ALIGN parameter is not. \"SYSMAC(foldername)\" ALIGN Option Scope Default Description @filename MALE Options in Z390.OPT file if found. Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. If a file named Z390.OPT exists in the z390 install directory, these options will be applied first as default options. ALIGN A YES Align DS/DC data fields based on type unless explicit length is specified. If duplication factor is 0, then NOALIGN is ignored. ALLOW M NO Allow extensions to HLASM syntax including: 1) No quotes required for SETC variables. 2) Duplication factor does not require (..). 3) Array declarations with variables in expression accepted 4) Substring starting beyond end returns null string 5) Quoted strings allowed in SETA and SETB expressions 6) Allow &var as null string if not found during substitution 7) Allow duplicate local and global variable declarations 8) Allow AREAD and PUNCH file records greater than 80 characters. The default of NOALLOW insures HLASM compatibility. AMODE24 LE NO Set 390 load module options to start in 24 bit address mode. AMODE31 LE YES Set 390 load module options to start in 31 bit address mode. ASCII AE NO Generate ASCII versus EBCDIC DC character constants, compare character strings in ASCII versus EBCDIC in macro processor, generate ASCII versus EBCDIC output for UNPK, ED, and EDMK. Note ASCII mode is not mainframe compatible and requires careful review of program to insure no EBCDIC immediate compare constants such as X'40', 64, X'F0', 240 etc. are used and that there are no assumptions about EBCDIC versus ASCII collating sequences which have numbers and letters reversed, and EBCDIC letters are non-contiguous. Typically HLASM compatible programs are run in default EBCDIC mode and DCB RECFM=FT|VT or some other translation option is used to convert between EBCDIC and ASCII where necessary. Note there are a few instructions affected by ASCII mode: 1) ED/EDMK generate ASCII versus EBCDIC but the mask must always be in EBCDIC (masks are usually coded in X'...' format) 2) UNPK generates X'3' versus X'F' in zone field (high order nibble). ASM MA YES Run az390 assembler as subtask of mz390 passing BAL. Note NOASM is for use in pure text processing programs which only use conditional macro code and AREAD/PUNCH with extensions to process ASCII text files. NOASM does not support ordinary symbol attribute tests, OPSYN, or lookahead mode, and requires CHKMAC(0) and CHKSRC(0-2). ASSIST MAE NO Enable assembly and execution of ASSIST I/O and debugging instructions. This option also sets NOLOADHIGH. See ASSIST Support . AUTOLINK L YES Search for unresolved external references in SYSOBJ directory list which defaults to linklib. BAL M NO Generate BAL expanded assembler source file. BS2000 MA NO Support Siemens BS2000 assembler global variables. CHKMAC(0-2) M 0 Check macros during loading as follows: 0 - no checking 1- check for missing AGO and AIF labels and issue warning 2 - also check missing labels and also check for non comment text after MEND. CHKSRC(0-3) MA 1 Check input source files as follows: 0 - no checking 1 - check MLC or BAL input source files for any non-ASCII characters and issue error 2 - check MLC, MAC, CPY, and BAL input source files for any non-ASCII characters and issue error. 3 - also check for out of sequence characters in 73-80 or any non-blank characters beyond 80 and issue error. Note this should detect any EBCDIC literal character strings containing non-ASCII characters such as binary 0 byte which must be changed to hex X'00' type strings for portability. CICS MA NO Support EXEC CICS pre-processor expansion and constants. If this option is not on during macro expansion, PROLOG and EPILOG option settings will be ignored. CODEPAGE(ascii+ebcdic+LIST) MALE YES The default is CODEPAGE(ISO-8859-1+IBM1047). If +LIST is added the mapping of the 2 codepages along with printable character and Unicode values are displayed on ERR file. A hex dump of the tables and a list of the valid ASCII and EBCDIC Unicode Charset codepages are listed. You can replace the EBCDIC codepage name with a file specification such as IBM1047.HCP (example included) which is in hex dump format. The above defaults match z/OS. CON MALE YES Console output for all start/stop, error, trace, MNOTE's with level > 4, and WTO messages. When the TRACE??? option is specified, the CON option is turned off so only start/stop and abort error messages appear on console log. You can specify CON after last TRACE option to turn it back on if you want all display, trace, and error messages displayed on console log. All the trace messages appear on corresponding TR? file for each z390 program executed. DUMP E NO Generate full memory dump on LOG or TRE if abort. EDF M YES CICS Execution Diagnostic Facility. EPILOG M YES Generate epilog macro call DFHEIEND for CICS program at END statement if CICS option and EPILOG option are on. ERR(100) MALE 100 Terminate process if total errors for program exceeds limit. Use ERR(0) to eliminate any error limit and always generate PRN file. ERRSUM M NO Generate critical error summary on console and ERR file listing missing macros and copybooks. This option requires ASM option and is turned on automatically if missing macros or copybooks are found in the executed macro code path. When ERRSUM is on, ERR(0) is set to prevent abort prior to finding all macro and copybook references. All errors are listed on ERR file along with summary report. Note several iterations may be required to identify and resolve all missing macros and copybooks. GUAM E NO Support one or more GUI Graphical User Access Method dialogs for MCS, TN3270, or graphics user interface. INIT E YES Initialize all registers to hex x'F4', all memory to hex x'F5', and all uninitialized load module areas to x'F6' for easier identification of access to uninitialized registers, memory or program fields. Use NOINIT to perform low value initialization. INSTALL(dir) MALE NO Define alternate z390 install directory to run batch command. The default is set from Java property \"user.dir\". IPL(pgm) E none Execute 390 program at startup. LIST ALE YES Generate PRN, LST, and LOG files for assembler, linker, and execution respectively. LISTCALL MA YES Generate level macro call and exit comments in BAL file which are used by assembler to format first level macro calls preceding assembler lines with \"+\" for macro generated source. LISTUSE A YES List active USING definitions each time USING or DROP changes status in the PRN assembly listing file. LOADHIGH E YES Load programs and allocate memory for GETMAIN/STORAGE from high end of first FQE large enough to satisfy request. The ASSIST option changes this option to NOLOADHIGH causing initial program to load starting at X'8000' which simplifies relative address calculations. LOG(file) MALE pgm Set file name for ERR, TR?, and LOG files. The default is the program name. This option is required when running multiple copies of the same program via CMD startup in order to create separate unique ERR, TR?, and LOG files. Otherwise duplicate programs running in parallel will mod the same ERR, TR?, and LOG file. MAXCALL(50) M 50 Set limit for nested macro calls. MAXDISPLAY(80) M 80 Use to increase zCOBOL DISPLAY line size up to 256 characters. MAXESD(1000) AL 1000 Set limit for ESD sections or entries in one program. MAXFILE(1000) M 1000 Maximum macro and copybook files. MAXGBL(1000000) M 100000 Maximum global macro variables. MAXHEIGHT(600) E 600 Maximum pixel height for GUI dialog windows. MAXLCL(100000) M 100000 Maximum local macro variables. MAXLINE(200000) MA 200000 Maximum MLC, MAC, CPY, and BAL source lines that can be loaded into memory during an assembly. MAXLOG(1000000) MALE 1000000 Maximum GUI log file output before truncation begins by removing 50% to limit memory consumption. The only limit on size of log file is MAXSIZE. MAXPARM(100000) M 10000 Maximum length of any string during macro processing. This is an extension as HLASM limit is currently 1024. MAXPASS(2) A 2 Maximum passes of the BAL source by assembler to resolve forward nested symbol references prior to final pass to generate object code. The number of LOCTR statements is added to this limit in order to resolve the final address of each LOCTR section. MAXPC(50000) M 50000 Maximum pseudo code instructions held in cache before LRU replacement begins. MAXQUE(1000) E 1000 Maximum output queue length from any CMD started task before queue messages are automatically copied to GUI output log to conserve memory and prevent stall. MAXRLD(10000) L 10000 Maximum RLD relocation records allowed in a program. MAXSIZE(50) MALE 50 Maximum size of any output file in MB. MAXSYM(50000) MA 50000 Maximum symbols in one macro assembly. MAXWARN(4) MA 4 Maximum MNOTE warning level without generating error. MAXWIDTH(800) E 800 Maximum pixel width for GUI dialog windows. MCALL A NO List each macro call and exit on the PRN assembly listing in addition to first level calls if LISTCALL option is also on. MEM(1) E 1 Memory allocated for 390 program execution in MB. Note for RMODE31 loads and GETMAIN's memory above the 16 MB line must be allocated. For example MEM(32) would provide 16 MB below the line and 16 MB above. MINHEIGHT(150) E 150 Minimum pixel height for GUI dialog windows. MINWIDTH(150) E 150 Minimum pixel width for GUI dialog windows. MNOTE(0) MA 0 Control MNOTE error/warning messages during macro expansion and assembly: 0 - default generates MNOTE error/warning during mz390 and az390 1 - suppress mz390 error/warning and only pass MNOTE to az390 2 - generates MNOTE error/warning during mz390 and suppresses passing them on to az390. MOD L NO Generate raw code file from lz390 with .MOD suffix and no header or trailer and no RLD's. OBJ A YES Generate relocatable object code file. OBJHEX A NO Generate ASCII readable form of OBJ file with support for 31 bit long sections. The default is to generate binary OBJ file which is compatible with mainframe linkers but is limited to 24 bit long sections. PARM('text') E none Define character string parm passed to executable program via address in R1 at startup pointing to a fullword pointing to a halfword length followed by EBCDIC characters. When the length is zero, no PARM is present. PC M YES Generate macro pseudo code in cache memory for speeding up macro code that is executed more than once during macro expansion. PCOPT M YES Optimize macro pseudo code by looking for push, add/sub, store sequences and replacing them with inc/dec pseudo code opcodes. These pseudo codes are maintained in a cache in memory during macro execution only and have no effect on generated object code. PRINTALL A NO Suppress PRINT OFF and PRINT NOGEN commands to force all source lines on PRN listing. PDSMEM8 M NO If PDSMEM8 option is specified, error messages will be issued for any macro or copybook file names with length greater than 8. This option is available to provide compatibility with mainframe PDS libraries that are limited to 8 character names. Note zCOBOL and zCICS use names longer than 8 characters such as zcobol\\IDENTIFICATION.MAC and cics\\CICS_INQUIRE.MAC. PROFILE(file) M NO Insert COPY file in front of MLC source file. PROLOG M YES Generate CICS prolog macro calls DFHEIGBL, DFHEISTG, and DFHEIENT if CICS option and PROLOG options are on. PROTECT E YES Prevent modification of PSA in low memory 8K block. REFORMAT M NO Reformat expanded BAL code to align all opcodes at column 10 and operands at column 16 if possible. REGS E NO Generate GPR register trace before and after each instruction if TRACE option on. RMODE24 LE YES Set 390 load module options to load module below the 24 bit address line. RMODE31 LE NO Set 390 load module options to load module above the 31 bit address line. Note this load module option requires option MEM be set to include enough memory above the 31 bit address line. STATS or STATS(file) MALE NO Generate statistics file STA with final options listing, macro and copybook file listing, plus all program statistics. If file is omitted the program path and file name are used with STA suffix. SYS390(dir) LE pgm dir Define directory for storing and retrieving 390 load modules. SYSBAL(dir) MA pgm dir Define directory for storing and retrieving generated BAL files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSCPY(dir) MA pgm dir Define one or more directories for retrieving CPY source input files. If the option starts with + the directories listed will be concatenated with current list. Multiple directories are always separated by +. This option may also override suffix by adding *.sfx. SYSDAT(dir) M pgm dir Define directory for retrieving DAT source input files for AREAD. Set to SYSDAT(.) for current directory when no path is specified on DSNAME parm for AREAD. SYSERR(dir) MALE pgm dir Define directory for output ERR files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLKD(file) L pgm dir Define input source file for linker commands such as INCLUDE, ALIAS, ENTRY, and NAME. SYSLOG(dir) E pgm dir Define directory for output LOG file. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLST(dir) AL pgm dir Define directory for output LST files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSMAC(dir) M mac dir Define one or more directories for source MAC files. If the option starts with + the directories listed will be appended to the maclib list. Multiple directories can be specified in one parameter and are always separated by +. When you specify this option more than once and want previous parameter instructions to remain in place, ensure that you start parameter with a + otherwise it will drop prior directories. This option may also override suffix by adding *.sfx. SYSMLC(dir) MA pgm dir Define directory for source input MLC files. SYSOBJ(dir) AL pgm dir Define directory for OBJ relocatable object files. SYSOPT(dir) MALE pgm dir Define directory for @file option files. This option may override suffix using *.sfx. SYSPARM('text') M none Define text string which can be accessed by mz390 global macro variable &SYSPARM. SYSPCH(dir) M pgm dir Define directory for PCH output files from PUNCH. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). Note PUNCH output is in ASCII source format and is not directed to the OBJ file. These files may be used as linker input commands via SYSLKD(file) option. Set to SYSPCH(.) for current directory when no path is specified on DSNAME parm for PUNCH. SYSPRN(dir) A pgm dir Define directory for assembler listing PRN output files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSTERM(file) MALE pgm.ERR Define alternate file for all start/end messages plus any error messages, plus related source file statistics for each file containing errors. The default is the program name with ERR suffix. SYSTRC(dir) MALE pgm dir Define directory for output TRACE TR? files. TEST E NO Start execution with interactive TEST mode active which prompts for commands such as T opcode or G opcode to trace or execution to the next occurrence of opcode name. TEST(ddname) E NO Define input command file to run TEST commands. ddname is an environment variable set to the name of the command file. THREAD A NO Assign continuing CSECT addresses for multiple CSECT's assembled in the same module to help identify location of instruction and data labels. TIME or TIME(seconds) MALE YES Limit execution time of each program to the number of seconds specified. The default is 15 seconds. This option is turned off if NOTIMING specified. Use NOTIME to allow tasks such as SOA servers like z390CICS to run continuously while still supporting application use of timing functions. TIMING MALE YES Calculate elapsed time and instructions per second statistics for display on START/END messages and STA statistics. TIMING also displays current z390 and J2SE version on start message and memory usage on ended message. Note NOTIMING is used in regression tests to force generated files to be identical by using fixed data/time stamp using GregorianCalendar(2005,0,2,22,33,44). NOTIMING suppresses versions on start message and memory usage on ended message. NOTIMING also sets NOTIME which prevents application from using time functions. TRACE or TRACE(AEGILMPQTV) E NO Turn on ez390 execution trace generation on TRE file and turn off CON. TRACE will display every instruction executed along with address and value of each operand. Any combination of the following trace options can be set using the TRACE(...) option. TRACE(*) will also set TRACEALL. Note the &SYSTRACE global SETC variable can be used to turn any trace options on or off during execution. TRACEA or TRACE(A) A NO Turn on az390 assembly trace generation on TRA file and turn off CON. TRACEA will display each BAL statement during each pass of the assembler. TRACEALL MALE NO Turn on all trace options generating TRM, TRA, TRL, and TRE files and turn off CON. TRACEC or TRACE(C) M NO Trace copy file code for TRACEM and TRACEP. The default is NOTRACEC to eliminate redundant code that usually just contains global variable declarations. TRACEG or TRACE(G) E NO Turn on ez390 emulator trace generation on TRE file with trace of GETMAIN/FREEMAIN FQE memory management control block changes and turn off CON. TRACEI or TRACE(I) M NO TRACEI will trace each AINSERT showing source on the TRM trace file. TRACEL or TRACE(L) L NO Turn on lz390 linker trace generation on TRL file and turn off CON. TRACEL shows each CSECT, ENTRY, EXTRN and OBJ file being loaded. TRACEM or TRACE(M) M NO Turn on mz390 macro processor trace generation on TRM file and turn off CON. TRACEM displays each conditional macro statement executed plus stored values and AIF compare values. TRACEP or TRACE(P) M NO Turn on mz390 macro processor pseudo code generation and execution trace on TRM file and turn off CON. TRACEP shows each conditional macro pseudo operation performed for each conditional macro statement and the values of all variables. TRACEQ or TRACE(Q) E NO Turn on ez390 emulator QSAM/BSAM DCB I/O trace generation on TRE file and turn off CON. TRACES or TRACE(S) M NO Display MLC source lines on console regardless of CON setting to help locate any loops, waits, or hangs in large macro process. If MCALL is also on, then *MCALL and *MEXIT comments will also be displayed to show location with nested macros. TRACET or TRACE(T) E NO Turn on ez390 emulator TGET/TPUT and TCP/IO trace generation on TRE file and turn off CON. TRACEV or TRACE(V) E NO Turn on ez390 emulator VSAM ACB/RPL I/O trace generation on TRE file and turn off CON. TRAP E YES Trap any unexpected J2SE program exceptions and generate emulator 0C5 exception which can be handled by SPIE/STAE exits if defined. NOTRAP can be used with Eclipse source debugger to stop at J2SE statement causing exception. TS MALE NO Generate JDBC compatible time-stamp on all TRACE and ERR file records for use in debugging time dependent issue. VCB E YES Generate VSAM cache buffer for improving VSAM performance by storing most recently accessed records and indexes. XREF A YES Cross reference symbols to source lines in PRN assembly listing. ZSTRMAC M YES Support expansion of ZSTRMAC structured conditional macro code instructions during loading of MLC, MAC, and CPY files. Note z390 macros in z390\\mac directory now are using zstrmac for structured coding. NOZSTRMAC can only be used with MVS, VSE, or other non-structured macro libraries. ZVSAM E 0 ZVSAM 0=no vsam, 1=zvsam1 support, 2=zvsam2 support.","title":"z390 Options"},{"location":"Options/zCOBOL_filetypes/","text":"zCOBOL file types TYPE Format File Description File or Report Format Description CBL ASCII COBOL source program 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. CPZ ASCII COBOL copy book member 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. MLC ASCII Macro assembler source program generated by phase 1 of the zCOBOL compiler which uses zcobol.class regular expression based parser in z390.jar to read CBL source file and create MLC source file in one pass. Macro call for each COBOL statement starting in area A and for each COBOL verb found in area B. Working storage data items are mapped to WS macro call with level as first parameter. Each macro call name is followed by positional parameters found following verb up to next verb or period. Periods are mapped to PERIOD macro call. Parameters of the form keyword(..) are passed as single parameter. Other ( and ) are passed as separate parameter in quotes. BAL ASCII HLASM compatible source code generated by phase 2 of the zCOBOL compiler when using CBLC, CBLCL or CBLCLG commands. HLASM compatible source statements generated by the zCOBOL macros during expansion of the generated MLC file. CPY ASCII Generated copy file containing macro calls to define labels defined in a zCOBOL program. LABEL generated zCOBOL name.","title":"zCOBOL file types"},{"location":"Options/zCOBOL_filetypes/#zcobol-file-types","text":"TYPE Format File Description File or Report Format Description CBL ASCII COBOL source program 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. CPZ ASCII COBOL copy book member 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. MLC ASCII Macro assembler source program generated by phase 1 of the zCOBOL compiler which uses zcobol.class regular expression based parser in z390.jar to read CBL source file and create MLC source file in one pass. Macro call for each COBOL statement starting in area A and for each COBOL verb found in area B. Working storage data items are mapped to WS macro call with level as first parameter. Each macro call name is followed by positional parameters found following verb up to next verb or period. Periods are mapped to PERIOD macro call. Parameters of the form keyword(..) are passed as single parameter. Other ( and ) are passed as separate parameter in quotes. BAL ASCII HLASM compatible source code generated by phase 2 of the zCOBOL compiler when using CBLC, CBLCL or CBLCLG commands. HLASM compatible source statements generated by the zCOBOL macros during expansion of the generated MLC file. CPY ASCII Generated copy file containing macro calls to define labels defined in a zCOBOL program. LABEL generated zCOBOL name.","title":"zCOBOL file types"},{"location":"Options/zCOBOL_options/","text":"zCOBOL options Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the FLOAT parameter is quoted as it uses parentheses, whereas the COMMENT parameter is not. \"FLOAT(BINARY)\" COMMENT Option Default Description @file NO Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. CICS NO Parse COBOL EXEC CICS commands into z390 EXEC CICS compatible macro calls and also rename working storage to DFHEISTG. COMMENT YES Generate MLC comments showing original COBOL statement preceding each macro call statement. EXTEND YES Support up to 31 digits for DISPLAY (Z) and COMP-3 (P) type data items rather than limiting precision to ANSI 1985 standard of 18. FLOAT(DECIMAL) YES Set type of floating point for usage FLOAT-SHORT, FLOAT-LONG, and FLOAT-EXTENDED. The choices are FLOAT(HEX) for Hexadecimal Floating Point (HFP) like COMP-1 and COMP-2, FLOAT(BINARY) for Binary Floating Point (BFP), or the default FLOAT(DECIMAL) for Decimal Floating Point (DFP). R64 YES Generate 64 bit instructions for the 16 GPR registers where appropriate. NOR64 restricts code generation to only use lower 32 bits of 16 GPR registers as required by z/VSE and some other operating environments. (Note option TRUNC and NOR64 results in use of DXR instead of DGR which is more efficient.) TRACE NO Generate WTO display of paragraph name at entry to each new paragraph in procedure division. This provides high level trace as opposed to using the z390 TRACE(E) option which generates instruction level trace. TRUNC NO Truncate binary data types F, G, and H to specified number of digits in PICTURE. WARN YES Generate level 4 MNOTE warnings from zCOBOL macros.","title":"zCOBOL options"},{"location":"Options/zCOBOL_options/#zcobol-options","text":"Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the FLOAT parameter is quoted as it uses parentheses, whereas the COMMENT parameter is not. \"FLOAT(BINARY)\" COMMENT Option Default Description @file NO Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. CICS NO Parse COBOL EXEC CICS commands into z390 EXEC CICS compatible macro calls and also rename working storage to DFHEISTG. COMMENT YES Generate MLC comments showing original COBOL statement preceding each macro call statement. EXTEND YES Support up to 31 digits for DISPLAY (Z) and COMP-3 (P) type data items rather than limiting precision to ANSI 1985 standard of 18. FLOAT(DECIMAL) YES Set type of floating point for usage FLOAT-SHORT, FLOAT-LONG, and FLOAT-EXTENDED. The choices are FLOAT(HEX) for Hexadecimal Floating Point (HFP) like COMP-1 and COMP-2, FLOAT(BINARY) for Binary Floating Point (BFP), or the default FLOAT(DECIMAL) for Decimal Floating Point (DFP). R64 YES Generate 64 bit instructions for the 16 GPR registers where appropriate. NOR64 restricts code generation to only use lower 32 bits of 16 GPR registers as required by z/VSE and some other operating environments. (Note option TRUNC and NOR64 results in use of DXR instead of DGR which is more efficient.) TRACE NO Generate WTO display of paragraph name at entry to each new paragraph in procedure division. This provides high level trace as opposed to using the z390 TRACE(E) option which generates instruction level trace. TRUNC NO Truncate binary data types F, G, and H to specified number of digits in PICTURE. WARN YES Generate level 4 MNOTE warnings from zCOBOL macros.","title":"zCOBOL options"}]}